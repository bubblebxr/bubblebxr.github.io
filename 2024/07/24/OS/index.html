<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BUAA_OS_final"><meta name="keywords" content="笔记,OS"><meta name="author" content="bubble"><meta name="copyright" content="bubble"><title>BUAA_OS_final | bubble's blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '7.3.0'
} </script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="bubble's blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text"> 引入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.</span> <span class="toc-text"> 操作系统发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text"> 特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 虚拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 异步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text"> 运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text"> 系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text"> 体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.</span> <span class="toc-text"> 中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 基本原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD"><span class="toc-number">2.</span> <span class="toc-text"> 链接与装载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">2.1.</span> <span class="toc-text"> 链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8Felf"><span class="toc-number">2.1.0.1.</span> <span class="toc-text"> 可执行文件格式（ELF）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.0.1.1.</span> <span class="toc-text"> 结构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E8%BD%BD%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text"> 装载和运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text"> 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">3.1.</span> <span class="toc-text"> 内存空间的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 连续分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">3.1.1.1.</span> <span class="toc-text"> 单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.1.1.2.</span> <span class="toc-text"> 固定分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.1.2.1.</span> <span class="toc-text"> 加载程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%BC%8F%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.1.3.</span> <span class="toc-text"> 可变式分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.1.3.1.</span> <span class="toc-text"> 跟踪内存使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">3.1.1.3.1.1.</span> <span class="toc-text"> 位图表示法（空闲分区表）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E9%93%BE"><span class="toc-number">3.1.1.3.1.2.</span> <span class="toc-text"> 链表表示法（空闲分区链）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.1.3.2.</span> <span class="toc-text"> 可变分区管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98"><span class="toc-number">3.1.1.3.3.</span> <span class="toc-text"> 回收内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.1.3.4.</span> <span class="toc-text"> 分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E5%9F%BA%E4%BA%8E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2"><span class="toc-number">3.1.1.3.4.1.</span> <span class="toc-text"> 分配算法（基于顺序搜索）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95"><span class="toc-number">3.1.1.3.4.2.</span> <span class="toc-text"> 分配算法（基于索引）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E7%B4%A7%E5%87%91%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.1.3.4.3.</span> <span class="toc-text"> 消除外部碎片：紧凑技术。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.1.1.4.</span> <span class="toc-text"> 多重分区分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">3.1.2.1.</span> <span class="toc-text"> 覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.1.2.2.</span> <span class="toc-text"> 交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.2.3.</span> <span class="toc-text"> 区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 非连续分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.3.1.</span> <span class="toc-text"> 页式内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.1.3.1.1.</span> <span class="toc-text"> 一级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#font-colorred-font-weightbold%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2font"><span class="toc-number">3.1.3.1.1.1.</span> <span class="toc-text"> *逻辑地址到物理地址的转换</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.1.3.1.2.</span> <span class="toc-text"> 多级页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8tlb"><span class="toc-number">3.1.3.1.3.</span> <span class="toc-text"> 快表TLB</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.1.3.1.3.1.</span> <span class="toc-text"> 哈希页表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.1.3.1.3.2.</span> <span class="toc-text"> 反置页表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.1.3.1.4.</span> <span class="toc-text"> 页共享与保护</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.3.2.</span> <span class="toc-text"> 段式内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.3.2.1.</span> <span class="toc-text"> 地址转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E5%85%B1%E4%BA%AB"><span class="toc-number">3.1.3.2.2.</span> <span class="toc-text"> 信息共享</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.3.3.</span> <span class="toc-text"> 段页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-2"><span class="toc-number">3.1.3.3.1.</span> <span class="toc-text"> 地址转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x86"><span class="toc-number">3.1.3.3.2.</span> <span class="toc-text"> X86</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85"><span class="toc-number">3.2.</span> <span class="toc-text"> 内存空间的扩充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.1.1.</span> <span class="toc-text"> 局部性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Ecache%E4%B8%BB%E5%AD%98%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">3.2.1.2.</span> <span class="toc-text"> 与Cache主存的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.1.3.</span> <span class="toc-text"> 请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.1.3.1.</span> <span class="toc-text"> 地址映射问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E5%85%A5%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.1.3.2.</span> <span class="toc-text"> 调入问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.1.3.3.</span> <span class="toc-text"> 页面置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.1.3.4.</span> <span class="toc-text"> 更新问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E4%B8%8E%E9%A9%BB%E7%95%99%E9%9B%86%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.1.4.</span> <span class="toc-text"> 工作集与驻留集管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.1.4.1.</span> <span class="toc-text"> 抖动问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.1.4.2.</span> <span class="toc-text"> 页面清除策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%8A%80%E6%9C%AF"><span class="toc-number">3.2.1.4.3.</span> <span class="toc-text"> 写时复制技术</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%87%AA%E6%98%A0%E5%B0%84"><span class="toc-number">3.3.</span> <span class="toc-text"> 页目录自映射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text"> 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="toc-number">4.1.1.1.</span> <span class="toc-text"> 进程执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">4.1.1.1.1.</span> <span class="toc-text"> 顺序执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-2"><span class="toc-number">4.1.1.1.2.</span> <span class="toc-text"> 并发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-number">4.1.1.1.3.</span> <span class="toc-text"> 并行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">4.1.1.2.</span> <span class="toc-text"> 进程状态与控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97pcb"><span class="toc-number">4.1.1.3.</span> <span class="toc-text"> 进程控制块PCB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD"><span class="toc-number">4.1.1.3.1.</span> <span class="toc-text"> 原语</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8E%9F%E8%AF%ADfork"><span class="toc-number">4.1.1.3.1.1.</span> <span class="toc-text"> 创建原语fork</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%8E%9F%E8%AF%ADkill"><span class="toc-number">4.1.1.3.1.2.</span> <span class="toc-text"> 撤销原语kill</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AE%B9"><span class="toc-number">4.1.1.3.2.</span> <span class="toc-text"> 内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.1.3.3.</span> <span class="toc-text"> 组织方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.2.1.</span> <span class="toc-text"> 线程实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.2.1.1.</span> <span class="toc-text"> 用户级线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.2.1.2.</span> <span class="toc-text"> 内核级线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.2.1.3.</span> <span class="toc-text"> 混合的线程实现方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#posix-pthreads"><span class="toc-number">4.1.2.2.</span> <span class="toc-text"> POSIX Pthreads</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">4.2.</span> <span class="toc-text"> 同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BF%99%E7%AD%89%E5%BE%85%E7%9A%84%E4%BA%92%E6%96%A5%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 基于忙等待的互斥方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.1.</span> <span class="toc-text"> 软件方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-number">4.2.1.1.1.</span> <span class="toc-text"> 单标志法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-number">4.2.1.1.2.</span> <span class="toc-text"> 双标志检查法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dekker%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.1.1.3.</span> <span class="toc-text"> Dekker算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#peterson%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.1.1.4.</span> <span class="toc-text"> Peterson算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.2.</span> <span class="toc-text"> 硬件方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.2.1.</span> <span class="toc-text"> 中断屏蔽方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#test-and-set%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.1.2.2.</span> <span class="toc-text"> Test and Set指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#spinlocks%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.2.1.2.3.</span> <span class="toc-text"> Spinlocks自旋锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%85%B1%E6%80%A7"><span class="toc-number">4.2.1.3.</span> <span class="toc-text"> 算法共性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 基于信号量的同步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.2.2.1.</span> <span class="toc-text"> 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text"> 分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">4.2.2.1.2.</span> <span class="toc-text"> 作用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.2.1.2.1.</span> <span class="toc-text"> 实现进程同步</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">4.2.2.1.2.2.</span> <span class="toc-text"> 实现前驱关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">4.2.2.1.2.3.</span> <span class="toc-text"> 实现进程互斥</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86"><span class="toc-number">4.2.2.2.</span> <span class="toc-text"> 信号量集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 基于管程的同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hoare%E7%AE%A1%E7%A8%8B"><span class="toc-number">4.2.3.1.</span> <span class="toc-text"> Hoare管程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.3.1.1.</span> <span class="toc-text"> 信号量定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.4.</span> <span class="toc-text"> 进程通信的主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">4.2.4.1.</span> <span class="toc-text"> 管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.4.2.</span> <span class="toc-text"> 消息传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">4.2.4.3.</span> <span class="toc-text"> 共享内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.5.</span> <span class="toc-text"> 经典进程同步与互斥问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.5.1.</span> <span class="toc-text"> 生产者-消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.5.2.</span> <span class="toc-text"> 读者-写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E4%BC%98%E5%85%88"><span class="toc-number">4.2.5.2.1.</span> <span class="toc-text"> 读优先</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%85%AC%E5%B9%B3"><span class="toc-number">4.2.5.2.2.</span> <span class="toc-text"> 读写公平</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E4%BC%98%E5%85%88"><span class="toc-number">4.2.5.2.3.</span> <span class="toc-text"> 写优先</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.5.3.</span> <span class="toc-text"> 哲学家进餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%A4%9A%E5%8F%AA%E5%85%81%E8%AE%B8%E5%9B%9B%E4%B8%AA%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%8C%E6%97%B6%E5%B0%9D%E8%AF%95%E8%BF%9B%E9%A4%90%E7%A0%B4%E9%99%A4%E8%B5%84%E6%BA%90%E4%BA%92%E6%96%A5"><span class="toc-number">4.2.5.3.1.</span> <span class="toc-text"> 最多只允许四个哲学家同时（尝试）进餐——破除资源互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E6%8B%BF%E8%B5%B7%E4%B8%A4%E6%A0%B9%E7%AD%B7%E5%AD%90%E5%90%A6%E5%88%99%E4%B8%8D%E6%8B%BF%E8%B5%B7%E7%A0%B4%E9%99%A4%E4%BF%9D%E6%8C%81%E7%AD%89%E5%BE%85"><span class="toc-number">4.2.5.3.2.</span> <span class="toc-text"> 同时拿起两根筷子，否则不拿起——破除保持等待</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%87%E6%95%B0%E5%8F%B7%E6%8B%BF%E5%B7%A6%E8%BE%B9%E5%81%B6%E6%95%B0%E6%8B%BF%E5%8F%B3%E8%BE%B9"><span class="toc-number">4.2.5.3.3.</span> <span class="toc-text"> 奇数号拿左边，偶数拿右边</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9D%A1%E8%A7%89%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88"><span class="toc-number">4.2.5.4.</span> <span class="toc-text"> 睡觉的理发师</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.</span> <span class="toc-text"> 调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.1.</span> <span class="toc-text"> CPU三级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 调度准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E8%80%83%E8%99%91%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 设计调度算法考虑问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%95%B0"><span class="toc-number">4.3.3.0.1.</span> <span class="toc-text"> 进程优先级（数）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E7%BB%84%E7%BB%87"><span class="toc-number">4.3.3.0.2.</span> <span class="toc-text"> 进程就绪队列组织</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%A0%E7%94%A8cpu%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.3.0.3.</span> <span class="toc-text"> 占用CPU方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%86%E7%B1%BB"><span class="toc-number">4.3.3.0.4.</span> <span class="toc-text"> 进程分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-number">4.3.3.0.5.</span> <span class="toc-text"> 时间片</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.4.</span> <span class="toc-text"> 批处理系统的调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1fcfs"><span class="toc-number">4.3.4.1.</span> <span class="toc-text"> 先来先服务FCFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88sjf"><span class="toc-number">4.3.4.2.</span> <span class="toc-text"> 短作业优先SJF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88srtn"><span class="toc-number">4.3.4.3.</span> <span class="toc-text"> 最短剩余时间优先SRTN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%AF%94%E4%BC%98%E5%85%88hrrn"><span class="toc-number">4.3.4.4.</span> <span class="toc-text"> 最高响应时间比优先HRRN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.5.</span> <span class="toc-text"> 交互式系统的调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%ACrr"><span class="toc-number">4.3.5.1.</span> <span class="toc-text"> 时间片轮转RR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95ps"><span class="toc-number">4.3.5.2.</span> <span class="toc-text"> 优先级算法PS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97mq"><span class="toc-number">4.3.5.3.</span> <span class="toc-text"> 多级队列MQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97mfq"><span class="toc-number">4.3.5.4.</span> <span class="toc-text"> 多级反馈队列MFQ</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E7%89%87%E5%86%85%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.5.4.1.</span> <span class="toc-text"> 线程调度：一个时间片内的调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%80%92%E7%BD%AE"><span class="toc-number">4.3.5.4.2.</span> <span class="toc-text"> 优先级倒置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.6.</span> <span class="toc-text"> 实时系统的调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%A1%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.6.1.</span> <span class="toc-text"> 静态表调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%80%9F%E7%8E%87%E8%B0%83%E5%BA%A6rms"><span class="toc-number">4.3.6.2.</span> <span class="toc-text"> 单调速率调度RMS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E6%97%A9%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95edf"><span class="toc-number">4.3.6.3.</span> <span class="toc-text"> 最早时间优先算法EDF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95llf"><span class="toc-number">4.3.6.4.</span> <span class="toc-text"> 最低松弛度优先算法LLF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.7.</span> <span class="toc-text"> 多处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%BC%8Famp"><span class="toc-number">4.3.7.1.</span> <span class="toc-text"> 非对称式AMP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%BC%8Fsmp"><span class="toc-number">4.3.7.2.</span> <span class="toc-text"> 对称式SMP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%8E%A7%E5%88%B6"><span class="toc-number">4.3.7.2.1.</span> <span class="toc-text"> 静态控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6"><span class="toc-number">4.3.7.2.2.</span> <span class="toc-text"> 动态控制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">4.4.</span> <span class="toc-text"> 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%E9%9D%99%E6%80%81"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 死锁预防（静态）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%E5%8A%A8%E6%80%81"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 死锁避免（动态）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.2.1.</span> <span class="toc-text"> 银行家算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">4.4.2.2.</span> <span class="toc-text"> 资源分配图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#rag%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.2.2.1.</span> <span class="toc-text"> RAG算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 死锁解除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text"> I&#x2F;O管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text"> I&#x2F;O管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%A7%92%E5%BA%A6"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 软件角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-2"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E7%AE%A1%E7%90%86%E7%9B%AE%E6%A0%87%E5%92%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.1.3.</span> <span class="toc-text"> I&#x2F;O管理目标和任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90"><span class="toc-number">5.2.</span> <span class="toc-text"> I&#x2F;O硬件组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 设备控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">5.2.1.1.</span> <span class="toc-text"> 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">5.2.1.2.</span> <span class="toc-text"> 组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.</span> <span class="toc-text"> I&#x2F;O控制技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6io"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 程序控制I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 中断驱动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma"><span class="toc-number">5.3.3.</span> <span class="toc-text"> DMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E9%80%9A%E9%81%93"><span class="toc-number">5.3.4.</span> <span class="toc-text"> I&#x2F;O通道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E8%BD%AF%E4%BB%B6%E7%BB%84%E6%88%90"><span class="toc-number">5.4.</span> <span class="toc-text"> I&#x2F;O软件组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">5.4.1.</span> <span class="toc-text"> 分层设计思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">5.4.2.</span> <span class="toc-text"> 设备独立性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%90%8D%E5%88%B0%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%90%8D%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">5.4.2.1.</span> <span class="toc-text"> 逻辑设备名到物理设备名的映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.4.3.</span> <span class="toc-text"> 设备驱动程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86"><span class="toc-number">5.5.</span> <span class="toc-text"> I&#x2F;O缓冲管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-number">5.5.1.</span> <span class="toc-text"> 单缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">5.5.2.</span> <span class="toc-text"> 双缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2"><span class="toc-number">5.5.3.</span> <span class="toc-text"> 环形缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">5.5.4.</span> <span class="toc-text"> 缓冲池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">5.6.</span> <span class="toc-text"> I&#x2F;O设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.1.</span> <span class="toc-text"> 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spooling%E6%8A%80%E6%9C%AF"><span class="toc-number">5.6.2.</span> <span class="toc-text"> SPOOLing技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">5.6.2.1.</span> <span class="toc-text"> 特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.</span> <span class="toc-text"> I&#x2F;O性能问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text"> 磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%84%E7%BB%87%E5%92%8C%E8%B0%83%E5%BA%A6"><span class="toc-number">6.1.</span> <span class="toc-text"> 磁盘的组织和调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E7%BB%87%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text"> 组织模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chs%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.1.1.</span> <span class="toc-text"> CHS模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lba%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.1.2.</span> <span class="toc-text"> LBA模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">6.1.2.</span> <span class="toc-text"> 空间管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4"><span class="toc-number">6.1.3.</span> <span class="toc-text"> 磁盘访问时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.4.</span> <span class="toc-text"> 磁盘调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E7%A3%81%E7%9B%98io%E6%80%A7%E8%83%BD"><span class="toc-number">6.2.</span> <span class="toc-text"> 提高磁盘I&#x2F;O性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%89%E4%BB%B7%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97raid"><span class="toc-number">6.3.</span> <span class="toc-text"> 廉价冗余磁盘阵列—RAID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#raid0"><span class="toc-number">6.3.1.</span> <span class="toc-text"> RAID0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raid1"><span class="toc-number">6.3.2.</span> <span class="toc-text"> RAID1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raid2"><span class="toc-number">6.3.3.</span> <span class="toc-text"> RAID2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raid3"><span class="toc-number">6.3.4.</span> <span class="toc-text"> RAID3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text"> 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text"> 文件系统基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-number">7.1.1.</span> <span class="toc-text"> 三个层次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text"> 文件系统实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">7.2.1.</span> <span class="toc-text"> 文件控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.2.</span> <span class="toc-text"> 文件逻辑结构和物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.2.1.</span> <span class="toc-text"> 文件逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.2.2.</span> <span class="toc-text"> 文件物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.2.2.1.</span> <span class="toc-text"> 连续（顺序）结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E8%81%94%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6"><span class="toc-number">7.2.2.2.2.</span> <span class="toc-text"> 串联&#x2F;链接文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.2.2.3.</span> <span class="toc-text"> 索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%A1%A8%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">7.2.2.2.3.1.</span> <span class="toc-text"> 索引表的组织</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">7.2.3.</span> <span class="toc-text"> 目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#final"><span class="toc-number">8.</span> <span class="toc-text"> Final</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E8%A7%82%E9%A2%98"><span class="toc-number">8.1.</span> <span class="toc-text"> 客观题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8A%E5%B0%8F%E6%B5%8B"><span class="toc-number">8.1.1.</span> <span class="toc-text"> 课上小测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="toc-number">8.1.2.</span> <span class="toc-text"> 算法相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA"><span class="toc-number">8.1.2.1.</span> <span class="toc-text"> 寻找空闲分区</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E5%9F%BA%E4%BA%8E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2-2"><span class="toc-number">8.1.2.1.0.1.</span> <span class="toc-text"> 分配算法（基于顺序搜索）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95-2"><span class="toc-number">8.1.2.1.0.2.</span> <span class="toc-text"> 分配算法（基于索引）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2-2"><span class="toc-number">8.1.2.2.</span> <span class="toc-text"> 页面置换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E5%8C%BA%E5%88%86"><span class="toc-number">8.1.3.</span> <span class="toc-text"> 混淆区分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E9%A2%98"><span class="toc-number">8.2.</span> <span class="toc-text"> 计算题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-2"><span class="toc-number">8.2.1.</span> <span class="toc-text"> 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5-2"><span class="toc-number">8.2.2.</span> <span class="toc-text"> 同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">8.2.2.1.</span> <span class="toc-text"> 习题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">8.2.3.</span> <span class="toc-text"> 作业调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">8.2.3.1.</span> <span class="toc-text"> 评价指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9"><span class="toc-number">8.2.3.2.</span> <span class="toc-text"> 算法内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81-2"><span class="toc-number">8.2.4.</span> <span class="toc-text"> 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE-2"><span class="toc-number">8.2.4.1.</span> <span class="toc-text"> 资源分配图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%BB"><span class="toc-number">8.2.4.1.1.</span> <span class="toc-text"> 画</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%96%E7%AE%80"><span class="toc-number">8.2.4.1.2.</span> <span class="toc-text"> 化简</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95-2"><span class="toc-number">8.2.4.2.</span> <span class="toc-text"> 银行家算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-2"><span class="toc-number">8.2.5.</span> <span class="toc-text"> 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84-2"><span class="toc-number">8.2.5.1.</span> <span class="toc-text"> 文件物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.5.1.1.</span> <span class="toc-text"> 连续结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E8%81%94%E9%93%BE%E6%8E%A5%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.5.1.2.</span> <span class="toc-text"> 串联&#x2F;链接结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-2"><span class="toc-number">8.2.5.1.3.</span> <span class="toc-text"> 索引结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="toc-number">8.2.5.2.</span> <span class="toc-text"> 计算文件大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">8.2.5.3.</span> <span class="toc-text"> 读取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%8F%96%E4%B8%8D%E8%AF%B4%E5%B0%B1%E6%98%AF%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%8F%96"><span class="toc-number">8.2.5.3.1.</span> <span class="toc-text"> 直接读取（不说就是直接读取）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inode%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96"><span class="toc-number">8.2.5.3.2.</span> <span class="toc-text"> inode方式读取</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98"><span class="toc-number">8.2.5.4.</span> <span class="toc-text"> 磁盘</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">bubble</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.cnblogs.com/qiuerOTO">全世界最好的xqjj</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/background.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">bubble's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">BUAA_OS_final</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-07-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/">大二下</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">30.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 96 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><meta name="referrer" content="no-referrer" />
<p><mark>关于内存地址如何转化成存储空间大小</mark></p>
<p>0x0000-0x1000，为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>6</mn><mn>3</mn></msup><mo>=</mo><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><mn>4</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">16^{3}=2^{12}=4k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，如果按字节寻址就是4KB，按字寻址就是4k字。</p>
<p>0d 十进制，0b 二进制，0o 八进制</p>
<p><strong>透明==不可见</strong></p>
<p>1s=1000ms</p>
<p>小端：数据的<strong>低位</strong>放在<strong>低地址</strong>空间，数据的<strong>高位</strong>放在<strong>高地址</strong>空间</p>
<p>大端：数据的<strong>高位</strong>放在<strong>低地址</strong>空间，数据的<strong>低位</strong>放在<strong>高地址空间</strong></p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406032131689.png" alt="" style="zoom:67%;" />
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406032131875.png" alt="" style="zoom: 67%;" />
<h1 id="引入"><a class="markdownIt-Anchor" href="#引入"></a> 引入</h1>
<p>冯若依曼体系结构：将程序指令存储器和数据存储器合并在一起的存储器结构</p>
<p>特权指令：只能在核心态执行</p>
<p>操作系统：<mark>管理计算机资源</mark></p>
<ul>
<li>处理机管理（进程，线程控制&amp;同步&amp;通信&amp;调度）</li>
<li>存储器管理（执行一个程序前需要将该程序放到内存中）</li>
<li>文件管理。</li>
<li>设备管理。（I/O摄像头的分配等等）</li>
</ul>
<p>用户接口：</p>
<ul>
<li>程序接口：通过<mark>系统调用</mark>请求OS为其提供服务。GUI——调用程序接口实现。<mark>系统调用是提供给应用程序的接口，只能通过用户程序间接使用</mark></li>
<li>命令接口：
<ul>
<li>联机命令接口：命令行一条命令，系统就响应一条。</li>
<li>脱机命令接口：<code>*.bat</code>文件集合多条命令。</li>
</ul>
</li>
</ul>
<p><strong>api和abi</strong></p>
<blockquote>
<p>abi：应用程序二进制接口，应用程序和操作系统之间。<strong>保证编译好的（二进制）代码，可以在 ABI 兼容的系统上都能运行</strong></p>
<p>api：programing应用程序编程接口，应用程序与开发人员之间，<strong>库函数</strong>。</p>
<p>区别：</p>
<ul>
<li>描述的内容不同。ABI 规定了二进制文件的格式、内容、装载/卸载程序的要求、函数调用时的参数传递规则、寄存器、堆栈的使用；API 规定操作系统、硬件平台、服务组件、语言函数库等需要提供的功能函数接口。</li>
<li>作用的层面不同。ABI描述二进制层面的接口，API描述代码级层面的接口。</li>
<li>兼容的难度不同。ABI的兼容程度比API更为严格，即ABI实现兼容更加困难。</li>
</ul>
</blockquote>
<h2 id="操作系统发展"><a class="markdownIt-Anchor" href="#操作系统发展"></a> 操作系统发展</h2>
<p><font color='orange'>手工操作阶段</font></p>
<p>用户独占全机，资源利用率低。</p>
<p><font color='orange'>批处理系统</font></p>
<p>CPU和I/O设备之间速度不匹配。</p>
<p>解决：将用户提交的作业成批送入计算机，作业调度程序自动选择作业运行。</p>
<p><strong>联机&amp;脱机</strong><font color="blue">[你航]</font></p>
<ul>
<li>联机批处理：作业的输入输出由CPU处理，缩短了建立作业和人工操作时间。（输入输出时CPU仍处于空闲状态）</li>
<li>脱机批处理：克服高速主机与慢速外设的矛盾，增加专门用于输入输出的卫星机，利用其完成输入输出，主机与卫星机并行工作。使主机摆脱I/O操作。
<ul>
<li>优：主机不直接与慢速的输入&amp;输出打交道</li>
<li>缺：内存仅存放一道作业，CPU等待低速的I/O作业</li>
</ul>
</li>
</ul>
<p><strong>单道&amp;多道</strong></p>
<ul>
<li>单道批处理系统：监督程序控制作业的输入/输出，但串行。内存中只有一道程序。</li>
<li>多道批处理系统：类似于流水线，多道程序并发执行，用户无法调试。允许多个程序同时进入内存并允许他们在CPU中交替运行（遇到I/O切换程序）
<ul>
<li>优：吞吐量大，资源利用率高，系统开销小</li>
<li>缺：<mark>平均周转时间长，交互能力差</mark></li>
</ul>
</li>
</ul>
<p><font color='orange'>分时系统</font></p>
<p>多个用户分享使用同一台计算机，但每个人都认为独占一个计算机。多个程序分时共享硬件和软件资源。把CPU处理时间分成时间片，按时间片轮流把处理器分配给不同程序，可人机交互。<strong>交互性作业</strong></p>
<p><strong>缺点：不能优先处理紧急任务</strong></p>
<p><font color='orange'>实时系统</font></p>
<p>优先紧急任务</p>
<p><font color="orange">网络操作系统和分布式计算机系统</font></p>
<p>网络操作系统：在传统单机OS上加单独软件层，主要提供联网功能和资源的远程访问，实现多机互联，通信。<strong>集中控制</strong></p>
<p>分布式计算机系统：系统中任意两台计算机通过通信方式交换信息，不同：<strong>分布式操作系统中的若干计算机相互协同完成同一任务</strong></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031921729.png" alt="" /></p>
<h2 id="特征"><a class="markdownIt-Anchor" href="#特征"></a> 特征</h2>
<h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3>
<p>两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观是交替发生。【并发性通过分时实现，进程——并发执行】</p>
<p>&amp;并行：两个或多个事件同一时刻同时发生。</p>
<p>单核CPU同一时刻只能执行一个程序，各个程序只能并发执行。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031843695.png" alt="" /></p>
<p>eg：显示屏与打印机，设备与设备</p>
<h3 id="共享"><a class="markdownIt-Anchor" href="#共享"></a> 共享</h3>
<p>资源共享，系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li>互斥共享：一个时间段只允许一个进程访问该资源。</li>
<li>同时共享：多个“同时”。</li>
</ul>
<h3 id="虚拟"><a class="markdownIt-Anchor" href="#虚拟"></a> 虚拟</h3>
<p>指把一个物理上的实体变为若干个逻辑上的对应物。</p>
<p>程序同时运行的内存远大于实际。空分复用技术（虚拟存储器技术），时分复用技术（虚拟处理器）。</p>
<h3 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h3>
<p>多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行走走停停，以不可预知的速度向前推进（被阻塞）。</p>
<h2 id="运行机制"><a class="markdownIt-Anchor" href="#运行机制"></a> 运行机制</h2>
<p>程序状态字寄存器：1“内核态”，0“用户态”。</p>
<ul>
<li>内核态：运行内核程序，执行特权指令。<mark>连接硬件与应用程序</mark>
<ul>
<li>与硬件关联紧密：时钟管理，中断处理（保护和恢复中断现场），设备驱动。</li>
<li>运行频率高：进程管理，存储器管理，设备管理。</li>
</ul>
</li>
<li>用户态：运行应用程序，执行非特权指令。</li>
</ul>
<p>刚开机，启动内核程序；之后主动将CPU让给应用程序，进入用户态。</p>
<h2 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h2>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062024334.png" alt="" /></p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062024550.png" alt="" style="zoom:50%;" />
<p>库函数封装调用系统调用。陷阱，运行在核心态。</p>
<p>凡是与共享资源有关的操作，都必须通过统一系统调用的发生向内核提出服务请求。</p>
<blockquote>
<p>是用户进程进入内核的接口层，本身不是内核函数，由内核函数实现。“类似于封装”</p>
</blockquote>
<h2 id="体系结构"><a class="markdownIt-Anchor" href="#体系结构"></a> 体系结构</h2>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062024482.png" alt="" style="zoom:50%;" />
<p>大内核：也包含进程管理、存储器管理、设备管理等（Linux，Windows）。</p>
<p>微内核：只包含时钟管理，中断处理。（上述只能运行在用户态，对性能造成影响）</p>
<ul>
<li>优点：内核容易实现，可移植性好，配置灵活。</li>
<li>缺点：速度慢。用户态和内核态相互切换频率高。</li>
</ul>
<h2 id="中断和异常"><a class="markdownIt-Anchor" href="#中断和异常"></a> 中断和异常</h2>
<p>陷阱和中断。</p>
<p><strong>同步&amp;异步</strong><font color="blue">[你航]</font></p>
<ul>
<li>同步异常：它是某一特定指令执行的结果。在相同条件下，异常可以重现。例如内存访问错误、调试指令以及被零除。</li>
<li>异步异常：不可预知。</li>
</ul>
<p><mark>中断是异步异常</mark>，可能随时发生，与处理器正在执行的内容无关。中断主要由I/O设备、处理器时钟或定时器产生，可以被启用或禁用。</p>
<p>系统调用=陷阱trap。</p>
<p>软件和硬件都可以产生中断（异常？），软件中断常称为陷阱trap</p>
<ul>
<li>陷阱(trap)帧：完整的线程描述表的子集，用于现场保护。</li>
<li>陷阱处理程序处理少量事件，多数转交给其他的内核或执行体模块处理。</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031718828.png" alt="" /></p>
<h3 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h3>
<p>不同的中断信号，使用不同的中断程序处理。查询中断向量表，找到中断处理程序在内存中存放的位置。</p>
<p>当产生中断信号时，操作系统会抢夺CPU重回内核态，执行中断的内核程序。</p>
<p><mark>没有中断就没有多道程序并发</mark></p>
<h1 id="链接与装载"><a class="markdownIt-Anchor" href="#链接与装载"></a> 链接与装载</h1>
<ul>
<li>编译：由编译程序将用户源代码编译成若干目标模块</li>
<li>链接：由链接程序将编译后的一组目标模块，以及它们所需的库函数链接在一起，形成一个完整的装入模块</li>
<li>装载/装入：由装入程序将装入模块装入内存运行
<ul>
<li>绝对装入：编译时产生绝对地址。（单道程序阶段：整个内存只有两个程序：用户程序和os）</li>
<li>可重定位装入：装入时将逻辑地址转换为物理地址（多道）</li>
<li>动态重定位：运行时将逻辑地址转换为物理地址，需要设置重定位寄存器（现代）</li>
</ul>
</li>
</ul>
<h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2>
<p>链接：将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。</p>
<p>作用：分离编译，多人协作。</p>
<p>编译-&gt;汇编-&gt;链接</p>
<h4 id="可执行文件格式elf"><a class="markdownIt-Anchor" href="#可执行文件格式elf"></a> 可执行文件格式（ELF）</h4>
<h5 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062024117.png" alt="" /></p>
<ul>
<li>
<p>ELF头</p>
<p>描述生成该文件的系统和字的大小和字节顺序（大小端存储模式）</p>
<p>帮助链接器语法分析和解释目标文件的信息。</p>
</li>
<li>
<p>节</p>
<ul>
<li>
<p>.text：已编译程序的机器代码。</p>
</li>
<li>
<p>.rodata：只读数据。<mark>const</mark>常量。</p>
</li>
<li>
<p>.data：<strong>已初始化</strong>的静态变量（当前模块内所有函数可见，模块外不可见）和已初始化的全局变量</p>
</li>
<li>
<p>.bss</p>
<ul>
<li><strong>未初始化和初始化为0</strong>的全局变量（所有模块可见）和未初始化的静态变量</li>
<li>局部 C 变量在运行时被保存在栈中</li>
<li>malloc出的区域在堆中</li>
</ul>
</li>
<li>
<p>.symtab：符号表。定义和引用的函数和全局变量的信息。<mark>每一个可重定位目标文件都有一张符号表</mark>。</p>
</li>
<li>
<p>.rel.text:  .text 节的重定位信息</p>
<p>在合并生成可执行文件时需要修改的指令的指针<br />
如：任何调用外部函数或者引用全局变量的指令</p>
</li>
<li>
<p>.rel.data（.rel.data.rel）:   .data节的重定位信息<br />
在合并生成可执行文件时需要修改的数据的指针<br />
任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改</p>
</li>
<li>
<p>.debug、.line：调试符号表</p>
</li>
<li>
<p>.strtab:  字符串表</p>
</li>
</ul>
</li>
<li>
<p>节头部表</p>
<p>描述各节的位置和大小，其中目标文件中每个节都有一个固定大小的条目 (项，entry)</p>
</li>
</ul>
<h2 id="装载和运行"><a class="markdownIt-Anchor" href="#装载和运行"></a> 装载和运行</h2>
<p>装载前的工作：shell调用fork()系统调用，创建一个子进程。</p>
<p>装载：可执行文件按照文件中的段映射（加载）到虚拟地址空间。（子进程调用execve()加载program）</p>
<p>加载：加载器在加载程序的时候看ELF文件和segment相关的信息。</p>
<p><mark>Type为Load的segment需要被加载到内存中的部分</mark></p>
<p>不一定全部加载到内存，如果文件中的大小小于在内存中的大小，补零。</p>
<blockquote>
<p>程序在装入时是否分配物理内存？不一定立即分配物理内存。</p>
<p>ELF的program header和section header分别起到什么作用？section header用来描述每个section的特性，如大小、类型、名称等等。program header用于描述segment的特性。</p>
</blockquote>
<h1 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h1>
<p>程序执行前需要先放到内存中才能被CPU处理。</p>
<ul>
<li>字word：看计算机有可能是32/16.</li>
<li>字节Byte：1Byte=8bit。</li>
<li>位bit：二进制位。</li>
</ul>
<p><mark>地址独立</mark>：无需知道物理内存的地址。</p>
<p><mark>存储保护</mark>：保证各进程在自己的内存空间内运行，不会越界访问。</p>
<ul>
<li>设置上下限寄存器：只有在两者之间才能访问。</li>
<li>重定位寄存器：存放进程的起始物理地址。界地址寄存器：最大逻辑地址。</li>
</ul>
<p>功能：</p>
<ul>
<li>存储分配和回收。</li>
<li>地址变换。</li>
<li>存储共享和保护。</li>
<li>存储器扩充。</li>
</ul>
<p>SRAM:读写速度快，成本高，Cache。</p>
<p>DRAM:读写速度慢，急程度高，容量大，主存。</p>
<p>存储层次结构：寄存器-Cache-主存-外存。</p>
<h2 id="内存空间的分配与回收"><a class="markdownIt-Anchor" href="#内存空间的分配与回收"></a> 内存空间的分配与回收</h2>
<ul>
<li><mark>内碎片：已经被分配出去（明确说出哪个进程）但不能被利用。单道连续分配）</mark></li>
<li><mark>外碎片：还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存。</mark></li>
</ul>
<h3 id="连续分配"><a class="markdownIt-Anchor" href="#连续分配"></a> 连续分配</h3>
<p>装入连续物理地址空间</p>
<h4 id="单一连续分配"><a class="markdownIt-Anchor" href="#单一连续分配"></a> 单一连续分配</h4>
<p>内存只有两个程序：系统区，用户区。内存中一道用户程序，独占整个用户区空间。运行前计算所有物理地址。</p>
<ul>
<li>静态地址翻译：即在程序运行之前就计算出所有物理地址。</li>
<li>静态翻译工作可以由加载器实现。</li>
</ul>
<p>优点：实现简单，没有外部碎片。</p>
<p>缺点：只能用于单用户、单任务，有内部碎片。</p>
<h4 id="固定分区分配"><a class="markdownIt-Anchor" href="#固定分区分配"></a> 固定分区分配</h4>
<p>分区：把内存分为一些大小相等或不等的分区，每个应用程序占用一个或几个分区。操作系统占用其中一个分区**。**</p>
<p>固定式分区：程序适应分区。</p>
<ul>
<li>分区大小相等：多个相同程序的并发执行。（控制多个相同对象）</li>
<li>分区大小不等：小中大，根据程序大小分配不同分区。（内碎片浪费）</li>
</ul>
<p>优点：没有外部碎片。</p>
<p>缺点：程序太大，不得不采用覆盖，降低性能；有内碎片。</p>
<h5 id="加载程序"><a class="markdownIt-Anchor" href="#加载程序"></a> 加载程序</h5>
<ul>
<li>
<p>单一队列分配方式：选择一个当前闲置且容量足够大的分区进行加载**，<strong>可采用共享队列的固定分区</strong>（**多个用户程序排在一个共同的队列里面等待分区）分配。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062024154.png" alt="" /></p>
</li>
<li>
<p>多队列：每个大小不同的分区都有一个队列，根据程序所需内存大小排在相应的队列。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062024419.png" alt="" /></p>
</li>
</ul>
<h4 id="可变式分区"><a class="markdownIt-Anchor" href="#可变式分区"></a> 可变式分区</h4>
<p>分区大小可变。（有外碎片，无内碎片）</p>
<h5 id="跟踪内存使用"><a class="markdownIt-Anchor" href="#跟踪内存使用"></a> 跟踪内存使用</h5>
<h6 id="位图表示法空闲分区表"><a class="markdownIt-Anchor" href="#位图表示法空闲分区表"></a> 位图表示法（空闲分区表）</h6>
<p>给每个分配单元赋予一个二进制数位，用来记录该分配单元是否闲置。（空间开销固定，时间开销低，没有容错能力）</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062024595.png" alt="" /></p>
<h6 id="链表表示法空闲分区链"><a class="markdownIt-Anchor" href="#链表表示法空闲分区链"></a> 链表表示法（空闲分区链）</h6>
<p>将分配单元按照是否闲置链接起来。（空间开销取决于程序数量，时间开销大，有一定容错能力链表有被占空间和闲置空间相互验证）</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062024827.png" alt="" /></p>
<h5 id="可变分区管理"><a class="markdownIt-Anchor" href="#可变分区管理"></a> 可变分区管理</h5>
<p>已分配分区表，未分配分区表。</p>
<ul>
<li>分配内存：<code>&lt;=size</code>不再进一步分割。<code>m.size（空闲分区）-u.size（请求分区）&lt;=size</code>，将该分区从分区表/链中移除，否则画出<code>u.size</code>分区。</li>
</ul>
<h5 id="回收内存"><a class="markdownIt-Anchor" href="#回收内存"></a> 回收内存</h5>
<p>相邻分区合并。</p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062024121.png" alt="" style="zoom:80%;" />
<h5 id="分配算法"><a class="markdownIt-Anchor" href="#分配算法"></a> 分配算法</h5>
<h6 id="分配算法基于顺序搜索"><a class="markdownIt-Anchor" href="#分配算法基于顺序搜索"></a> 分配算法（基于顺序搜索）</h6>
<ul>
<li>首次适应：按<mark>地址递增</mark>顺序排序，选择第一个满足要求的。空闲分区以地址递增的次序排列，按顺序查找空闲分区链&amp;表。
<ul>
<li>低地址不断划分，出现小碎片。</li>
<li>每次从低地址开始，增加查找可用分区的开销。</li>
</ul>
</li>
<li>下次适应：循环列表，从上次查找结束的地方开始。以地址递增的循环列表。
<ul>
<li>空间利用更加均衡，不会非小的集中在一端。缺乏大的空闲分区。</li>
</ul>
</li>
<li>最佳适应：选择大小最接近的。按容量递增次序排列。
<ul>
<li>小碎片。</li>
</ul>
</li>
<li>最坏适应：寻找最大的空闲区。按容量递减次序排列。
<ul>
<li>大作业申请得不到满足。</li>
</ul>
</li>
</ul>
<h6 id="分配算法基于索引"><a class="markdownIt-Anchor" href="#分配算法基于索引"></a> 分配算法（基于索引）</h6>
<p>适合小系统，否则空闲分区表/链很大，检索速度慢。</p>
<ul>
<li>快速适应：按容量大小分类，常用大小的空闲区设立单独的空闲区链表。系统为多个空闲链表设立一张管理索引表。
<ul>
<li>效率高，仅需要根据程序长度，找到能容纳最小空闲区链表，取下第一块。</li>
<li>不会分割分区，不产生内存碎片。取下某链表第一个即可。</li>
<li>回收算法复杂。</li>
</ul>
</li>
<li>伙伴系统：（linux）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n-1}&lt;x&lt;2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>，如果找不到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>就找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>再切割成两个相等的（伙伴）。
<ul>
<li>两个块合并成一个更大的块，首地址必须是块大小的整数倍</li>
<li>伙伴地址： 两个大小相同的相邻块合并成一个更大的块时，<strong>首地址必须是块（合成后的块2倍）大小的整数倍</strong>。</li>
<li><strong>并不是任意两个相同大小的内存区块都是伙伴</strong></li>
</ul>
</li>
</ul>
<h6 id="消除外部碎片紧凑技术"><a class="markdownIt-Anchor" href="#消除外部碎片紧凑技术"></a> 消除外部碎片：紧凑技术。</h6>
<p>消除外部碎片，使本来分散的多个小空闲分区连成一个大的空闲区。挪位。</p>
<p>紧凑时机：找不到足够大的空闲分区且总空闲分区容量可以满足作业要求。</p>
<p><mark>实现支撑——动态重定位：挪位。进程起始地址，重定位寄存器中修改。</mark></p>
<h4 id="多重分区分配"><a class="markdownIt-Anchor" href="#多重分区分配"></a> 多重分区分配</h4>
<p>将一道作业分成若干片段，增加程序短表，涉及到存储保护。</p>
<ul>
<li>界限寄存器方法：上下界寄存器，基址、限长寄存器。</li>
<li>存储保护键：每个存储块保护键，每个进入系统的作业保护键，两者不匹配则停止运行。</li>
</ul>
<h3 id="覆盖与交换"><a class="markdownIt-Anchor" href="#覆盖与交换"></a> 覆盖与交换</h3>
<p><mark>解决大作业在小内存中的运行问题</mark></p>
<h4 id="覆盖"><a class="markdownIt-Anchor" href="#覆盖"></a> 覆盖</h4>
<p>将程序划分为若干个功能上相对独立的程序段，按照程序的逻辑结构让那些不会同时执行的程序段共享同一块内存区的内存扩充技术。</p>
<p><strong>对用户不透明，增加了用户负担</strong></p>
<h4 id="交换"><a class="markdownIt-Anchor" href="#交换"></a> 交换</h4>
<p>将系统暂时不用的程序或数据部分或全部从主存中调出，以腾出空间将系统要求使用的程序和数据调入主存，实际上是主存与外存之间不断的交换程序和数据，以实现用户在较小的存储空间中完成较多作业的执行。</p>
<ul>
<li>优点：增加并发运行的程序数目，并且给用户提供适当的响应时间；编写程序时不影响程序结构</li>
<li>缺点：对换入和换出的控制增加处理机开销；程序整个地址空间都进行传送，没有考虑执行过程中地址访问的统计特性</li>
</ul>
<blockquote>
<p>换出等待I/O的进程</p>
<p>何时交换：不用&amp;内存空间不够</p>
<p>交换时工作：保存前一个进程的运行现场——寄存器，堆栈；创建新进程的运行现场</p>
<p>换回：恢复</p>
</blockquote>
<h4 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h4>
<p>一、结构不同</p>
<p>1、覆盖：要求程序员给出程序段之间的覆盖结构。</p>
<p>2、交换：不要求程序员给出程序段之间的交换结构。</p>
<p>二、进行不同</p>
<p>1、覆盖：主要在同一个作业或同一个进程内进行。</p>
<p>2、交换：主要是在进程或作业之间进行。</p>
<p>三、减少不同</p>
<p>1、覆盖：减少一个程序运行所需的空间。</p>
<p>2、交换：可让整个程序暂存于外村中，让出内存空间。</p>
<h3 id="非连续分配"><a class="markdownIt-Anchor" href="#非连续分配"></a> 非连续分配</h3>
<p><mark>充分利用空间，减少移动带来的开销</mark></p>
<h4 id="页式内存管理"><a class="markdownIt-Anchor" href="#页式内存管理"></a> 页式内存管理</h4>
<p><font color='orange'><strong>对用户透明</strong></font></p>
<ul>
<li>纯分页：不支持换页，不支持虚拟存储器功能，必须一次全装入主存，否则不能运行
<ul>
<li>没有外碎片，有内碎片</li>
<li>一个程序不必连续存放</li>
</ul>
</li>
<li>请求分页：不一次性装入</li>
</ul>
<h5 id="一级页表"><a class="markdownIt-Anchor" href="#一级页表"></a> 一级页表</h5>
<p>把一个逻辑地址连续的程序分散存放到若干不连续的内存区域。</p>
<ul>
<li>
<p>页&amp;页面（虚拟）：把每个作业&amp;进程的地址空间分成一些大小相等的片。从0开始编号。</p>
</li>
<li>
<p>页框（物理）：把内存分成与页面大小相同的片。</p>
</li>
</ul>
<p><mark>进程的页面与内存的页框一一对应</mark></p>
<p>页表：每个进程配置一张页表。页表的基址及长度由页表寄存器给出。页号-块号：实际只需存储块号，页号用数组下标表示。<mark>只是存放块号而不是地址</mark>。<strong>需要块号*内存块大小！</strong><font color="red">存放在内存中，访问数据需要访存2次，页表1次，内存1次。</font></p>
<ul>
<li>是否在内存中的标识位。</li>
<li>算法换出的标识位。</li>
<li>页面是否改动的脏位。</li>
</ul>
<p>页表项个数=页面数</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406032113519.png" alt="" /></p>
<h6 id="font-colorred-font-weightbold逻辑地址到物理地址的转换font"><a class="markdownIt-Anchor" href="#font-colorred-font-weightbold逻辑地址到物理地址的转换font"></a> <font color='red' font-weight='bold'>*逻辑地址到物理地址的转换</font></h6>
<ul>
<li>页表项位置=页表基地址+页号*页表项长度</li>
<li>根据页表项位的信息获得页框号。</li>
<li>物理地址：页框号*页大小+页内偏移（按字寻址&amp;按字节寻址）<mark>1字节=8位  1字=2字节（16位） 1字=4字节（32位）1字=8字节（64位）  1字节=16进制两位（一定注意前面为0的别漏数！！！）</mark></li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062025581.png" alt="" /></p>
<p>问题：逻辑地址空间很大，页表更大？实现困难。解决：多级页表。</p>
<h5 id="多级页表"><a class="markdownIt-Anchor" href="#多级页表"></a> 多级页表</h5>
<p>把外部页表（页表的页表：页表号-内存块号）调用到内存，动态调入内部页表。</p>
<p>将一级页表拆分，每个小分组刚好可以装入一个内存块。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062025555.png" alt="" /></p>
<p>由一级页号获得二级页表存放的位置，通过二级页号获得内存中存放的位置。</p>
<p>一级页号/页表项大小=一级页号</p>
<p><mark>二级页表大小与页面大小相同，即页表项大小*个数</mark></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062025626.png" alt="" /></p>
<p>问题：<strong>内存访问效率降低</strong>，由原先的1次增加为3次！（二级页表）解决：快表。</p>
<h5 id="快表tlb"><a class="markdownIt-Anchor" href="#快表tlb"></a> 快表TLB</h5>
<p>CPU产生逻辑地址的页号，首先在TLB中寻找，命中直接找出；未命中从页表中找出，再将相应页表项复制到快表。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062025275.png" alt="" /></p>
<p>有效内存访问时间：a为TLB命中率</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>A</mi><mi>T</mi><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi mathvariant="normal">单</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">访</mi><mi mathvariant="normal">问</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>+</mo><mi>T</mi><mi>L</mi><mi>B</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">询</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo stretchy="false">)</mo><mo>+</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi mathvariant="normal">单</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">访</mi><mi mathvariant="normal">问</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>×</mo><mn>2</mn><mo>+</mo><mi>T</mi><mi>L</mi><mi>B</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">询</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo>=</mo><mn>2</mn><mo>∗</mo><mi mathvariant="normal">单</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">访</mi><mi mathvariant="normal">问</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>+</mo><mi>T</mi><mi>L</mi><mi>B</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">询</mi><mo>−</mo><mi mathvariant="normal">单</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">访</mi><mi mathvariant="normal">问</mi><mo>∗</mo><mi>a</mi><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">单</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">访</mi><mi mathvariant="normal">问</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>+</mo><mi>T</mi><mi>L</mi><mi>B</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">询</mi></mrow><annotation encoding="application/x-tex">EAT=a(单次内存访问时间+TLB查询时间)+\\
(1-a)(单次内存访问时间\times2+TLB查询时间)\\
=2*单次内存访问时间+TLB查询-单次内存访问*a\\
=(2-a)*单次内存访问时间+TLB查询
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">询</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">询</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">询</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">询</span></span></span></span></span></p>
<ul>
<li>访问TLB=访问TLB+查询</li>
<li>访问内存中页表+访问内存</li>
</ul>
<h6 id="哈希页表"><a class="markdownIt-Anchor" href="#哈希页表"></a> 哈希页表</h6>
<p>通过虚拟页号的哈希值访问页表，每个页表项是一个链表，如果虚拟地址与两表中元素的第一个域相同，则匹配，第二个域形成物理地址。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062023365.png" alt="" /></p>
<h6 id="反置页表"><a class="markdownIt-Anchor" href="#反置页表"></a> 反置页表</h6>
<p>index——物理块号，每个页表项存放使用进程的pid和逻辑页号</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406051304743.png" alt="" /></p>
<p>如果检索整个页表都没有找到——缺页</p>
<p>不根据进程的逻辑页号组织，只与物理内存大小有关</p>
<h5 id="页共享与保护"><a class="markdownIt-Anchor" href="#页共享与保护"></a> 页共享与保护</h5>
<p>共享：需共享的数据&amp;代码的相应页面指向相同页框</p>
<p>问题：共享数据域不共享数据划在同一页框中，不易保密——分段存储管理 <mark>页式管理缺点：共享数据不方便！！！</mark></p>
<p>保护：</p>
<ul>
<li>地址越界保护</li>
<li>在页表中设置保护位：W，R，W/R</li>
</ul>
<h4 id="段式内存管理"><a class="markdownIt-Anchor" href="#段式内存管理"></a> 段式内存管理</h4>
<p><font color='orange'><strong>对用户可见，可以在用户编程时确定</strong></font></p>
<p>页式问题：难以满足程序运行时对内存的<strong>动态需求</strong>。<strong>不便于数据共享与保护</strong>。</p>
<p>段式（可变的页）：按照程序自身的逻辑关系分成若干个段。<mark>编程时需要显式给出段号、段内地址</mark></p>
<p>段表：保存在内存，基址及长度由段表寄存器给出。</p>
<ul>
<li>
<p>段表寄存器：<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062026447.png" alt="" /></p>
</li>
<li>
<p>逻辑地址：</p>
<table>
<thead>
<tr>
<th>31 …16</th>
<th>15 … 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>段号（位数决定的每个进程最多分几段</td>
<td>段内地址（位数决定了每个段最大长度）</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>段表（每个段表项长度相同，段号隐含）：</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062027310.png" alt="" /></p>
</li>
</ul>
<h5 id="地址转换"><a class="markdownIt-Anchor" href="#地址转换"></a> 地址转换</h5>
<ul>
<li>段表项地址=段号*段表项长度+段表始址。从而获得段长和基址。</li>
<li>判断逻辑地址中的段号S和段长TL，如果S&gt;TL，访问越界，产生越界中断。</li>
<li>基址与段内地址相加获得要访问的物理地址。</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062027502.png" alt="" /></p>
<h5 id="信息共享"><a class="markdownIt-Anchor" href="#信息共享"></a> 信息共享</h5>
<p>不同进程可以共享可重入代码（纯代码，多次并发调用安全运行，不能使用全局&amp;静态变量，不能修改代码本身）</p>
<p>优点：易于共享与保护，支持动态的内存需要</p>
<p>缺点：地址变换浪费时间，产生外部碎片（可通过紧凑解决，但时间代价大），辅存中管理不定长度的分段困难。</p>
<p>页式善于管理物理地址，段式善于管理逻辑地址。</p>
<p><strong>为什么页式是一维，段式是二维？</strong></p>
<p>页式虚拟地址从0一直到最大gb，是连续的；段式是好多个从0-特定的地址。分成好多段，数据段、代码段等等，段与段之间不是连续的地址。</p>
<p>页式给一个虚拟地址，可以自动划分页号和页内偏移，系统自动生成；段式程序员自己设定段号。</p>
<p><strong>省流：需要段长和段基址两个值才能确定某段</strong></p>
<h4 id="段页式存储管理"><a class="markdownIt-Anchor" href="#段页式存储管理"></a> 段页式存储管理</h4>
<p>将进程先分段（编程实现）再分页（对用户不可见），再存放在内存中</p>
<p>逻辑地址：<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062032723.png" alt="" /></p>
<ul>
<li>段号：每个进程最多分几段。</li>
<li>页号：位数每个段最大有几页。</li>
<li>页内偏移量：决定页面大小，内存块大小。</li>
</ul>
<h5 id="地址转换-2"><a class="markdownIt-Anchor" href="#地址转换-2"></a> 地址转换</h5>
<p>每个进程一张段表，每个段一张页表。<strong>段表中存放页表存放块号和页表长度</strong></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062032384.png" alt="" /></p>
<p>三次访存：1.根据段号查取页表长度和页表存放块号。2.根据页表存放块号访问页表获得内存块号。3.访存。</p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062034795.png" alt="" style="zoom:80%;" />
<h5 id="x86"><a class="markdownIt-Anchor" href="#x86"></a> X86</h5>
<p>段映射机制：逻辑地址——线性地址</p>
<p>页映射机制：线性地址——物理地址</p>
<p>全局描述符表GDT：段描述符</p>
<p>局部描述符表LDT：专属于某个任务的段描述符</p>
<h2 id="内存空间的扩充"><a class="markdownIt-Anchor" href="#内存空间的扩充"></a> 内存空间的扩充</h2>
<h3 id="虚拟内存管理"><a class="markdownIt-Anchor" href="#虚拟内存管理"></a> 虚拟内存管理</h3>
<h4 id="局部性问题"><a class="markdownIt-Anchor" href="#局部性问题"></a> 局部性问题</h4>
<p>空间局部性：刚访问过的存储单元的临近单位访问的可能性很高。</p>
<p>时间局部性：刚访问过的不能不久后会被再次访问。</p>
<p>虚拟存储提供3种能力：</p>
<ul>
<li>给所有进程提供一致的地址空间。</li>
<li>保护每个进程的地址空间不被其他进程破坏。</li>
<li>把主存作为磁盘的高速缓存。</li>
</ul>
<p><strong>原理</strong></p>
<p>程序装入时，不需要将全部读入内存（与覆盖不同，os自动完成，对程序员透明），程序执行时可以换入换出（比交换更小颗粒度）。</p>
<p>虚拟存储技术特征：</p>
<ul>
<li>离散型。物理内存分配不连续。</li>
<li>多次性。作业被多次调入内存。</li>
<li>对换性。允许作业换入换出。</li>
<li>虚拟性：允许程序从逻辑的角度访存存储器，而不考虑物理内存上可用的空间容量。</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062036163.png" alt="" /></p>
<h4 id="与cache主存的异同"><a class="markdownIt-Anchor" href="#与cache主存的异同"></a> 与Cache主存的异同</h4>
<p>相同点：</p>
<ul>
<li>出发点相同：提高存储系统的性能。</li>
<li>原理相同：利用程序运行时的局部性原理把最近的常用信息快调入相对高速而小容量的存储器。</li>
</ul>
<p>不同点：</p>
<ul>
<li>侧重点不同：cache解决主存与CPU的速度差异。虚存解决存储容量问题。</li>
<li>数据通路不同：CPU与cache和主存之间有直接访问通路，而虚存如果主存不命中只能通过调页解决。</li>
<li>透明性不同：<strong>cache管理由硬件完成</strong>，对系统程序员和应用程序员完全透明；<strong>虚存由os和硬件共同完成</strong>，对系统程序员不透明，对应用程序员透明。</li>
<li>未命中的损失不同：主存未命中的性能损失远大于cache未命中。</li>
</ul>
<h4 id="请求分页管理方式"><a class="markdownIt-Anchor" href="#请求分页管理方式"></a> 请求分页管理方式</h4>
<p>程序执行过程中，所访问的信息不在内存中，由os负责将所需信息从外存调入内存。若内存空间不够，os将内存中暂时用不到的信息换出到外存。</p>
<ul>
<li>硬件支持：请求分页的页表机制，缺页中断机构和地址变换机构。</li>
<li>软件支持：请求调页功能和页置换功能的软件。</li>
</ul>
<p>要解决的问题：</p>
<ul>
<li>地址映射问题：进程空间到虚拟存储的映射</li>
<li>调入问题：哪些程序和数据应被调入，调入机制</li>
<li>替换问题：哪些程序和数据被调出主存</li>
<li>更新问题：主存和赋存的一致性</li>
<li>其他：存储保护和程序重定位</li>
</ul>
<p>（进程的）虚拟地址空间=虚拟存储空间，都从0开始编址。</p>
<p>交换分区：<strong>连续的磁盘空间</strong>（按页划分），对用户不可见。物理内存不够时，os把内存中暂时不用的数据放在这里。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062037179.png" alt="" /></p>
<h5 id="地址映射问题"><a class="markdownIt-Anchor" href="#地址映射问题"></a> 地址映射问题</h5>
<p>程序装入时，由装载器Loader完成。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062039209.png" alt="" /></p>
<ul>
<li>驻留位：1表示在内存中，0表示在外存中。</li>
<li>保护位：只读，可写，可执行。</li>
<li>修改位：此页在内存中是否被修改过。</li>
<li>访问位：页面置换算法。</li>
</ul>
<h5 id="调入问题"><a class="markdownIt-Anchor" href="#调入问题"></a> 调入问题</h5>
<ul>
<li>预调页：事先调入页面的策略。</li>
<li>按需调页：仅当需要时才调入页面的策略。</li>
</ul>
<p>缺页异常&amp;中断处理机制。（懒惰交换）</p>
<p>为每个进程维护一个当前工作集合，如果进程在暂停之后需要重启时，根据这个列表使用预调页将所有工作集合中的页一次性调入内存。</p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406051400127.png" alt="" style="zoom:80%;" />
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406051400576.png" alt="" style="zoom:80%;" />
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406051401612.png" alt="" style="zoom:80%;" />
<h5 id="页面置换"><a class="markdownIt-Anchor" href="#页面置换"></a> 页面置换</h5>
<ul>
<li>最优置换：选择最长时间不需要访问的页面。（用于比较性研究）</li>
<li>先进先出：选择在主存驻留时间最长的一页淘汰。
<ul>
<li>性能较差，Belady异常（分配的页框增多，缺页率反而提高）</li>
</ul>
</li>
<li>second chance（改进FIFO）：如果被淘汰的数据之前被访问过，则给第二次机会，同时清除标志位，否则直接淘汰。</li>
<li>clock（改进FIFO）：环形循环指针。
<ul>
<li>无缺页错误：将访问页置1，指针不动</li>
<li>产生：
<ul>
<li>当前为1：置0，向前移，直至找到0，到当前为0的情况</li>
<li>当前为0：替换，将其置1，向前移一位</li>
</ul>
</li>
</ul>
</li>
<li>最近最少使用LRU：选择在最近一段时间内最久不用的页面。
<ul>
<li>命中时：所有块的计数值与命中块的计数值比较，
<ul>
<li>
<p>如果某块计数值小于命中块的计数值， 则该块的计数值加 1</p>
</li>
<li>
<p>如果该块的计数值大于命中块的计数值，则数值不变。</p>
</li>
<li>
<p>最后将命中块的计数器清为0。</p>
</li>
</ul>
</li>
<li>访问未命中：计数值最大的块被替换。被替换的清0，其余加1.</li>
</ul>
</li>
<li>工作集算法：工作集指进程运行正在使用的页面集合。给定一个进程，记录其工作集。当需要进行页面替换时，选择不在工作集中的页面进行替换。</li>
</ul>
<h5 id="更新问题"><a class="markdownIt-Anchor" href="#更新问题"></a> 更新问题</h5>
<ul>
<li>file backed&amp;未被修改：直接丢弃，磁盘有相同副本</li>
<li>file backed&amp;修改：写回原有文职</li>
<li>anonymous&amp;（第一次换出|已被修改）：写入swap</li>
<li>anonymous&amp;非（第一次换出&amp;已被修改）：丢弃</li>
</ul>
<h4 id="工作集与驻留集管理"><a class="markdownIt-Anchor" href="#工作集与驻留集管理"></a> 工作集与驻留集管理</h4>
<p>工作集：当前进程正在使用的页面集合。</p>
<p>驻留集：每个进程驻留在内存的页面集合。（应该给每个进程分配多少页框，分配过多并发运行进程数降低；分配过少，产生抖动问题）</p>
<h5 id="抖动问题"><a class="markdownIt-Anchor" href="#抖动问题"></a> 抖动问题</h5>
<p>解决办法：</p>
<ul>
<li>局部置换策略</li>
<li>引入工作集算法</li>
<li>预留部分界面</li>
<li>挂起若干进程
<ul>
<li>可挂起的进程：优先级最低、缺页进程、最后一个被激活的进程、驻留集最小的进程、最大的进程</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406051414924.png" alt="" /></p>
<p><strong>页面分配策略</strong></p>
<ul>
<li>固定分配策略：每个活动进程的驻留集大小在运行期间固定不变。</li>
<li>可变分配策略：页框数在其生命周期可变。（要求统计缺页率）</li>
</ul>
<p><strong>页面置换策略</strong></p>
<ul>
<li>局部置换策略：系统在进程自身的驻留集中判断当前是否存在空闲页框。</li>
<li>全局替换策略：整个进程空间判断是否存在空闲页框，允许从其他进程的驻留集中选择一个页面换出内存。</li>
</ul>
<p>可变+局部</p>
<h5 id="页面清除策略"><a class="markdownIt-Anchor" href="#页面清除策略"></a> 页面清除策略</h5>
<p>修改过的页面，如果在换出时要等待一个页面的写出和另一个页面的读入，降低处理机使用效率。</p>
<p><mark>页缓冲</mark></p>
<p>发生缺页中断时，不必首先写出置换页，而是将被选中的置换页面暂时保留在内存的缓冲区，批量写出到外存。减少IO次数。（页面缓冲算法）</p>
<h5 id="写时复制技术"><a class="markdownIt-Anchor" href="#写时复制技术"></a> 写时复制技术</h5>
<p>多个进程共享物理内存，如果想要写，就会在内存中复制一个页框写，新页框对写进程私有，其余不可见</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406051416245.png" alt="" /></p>
<h2 id="页目录自映射"><a class="markdownIt-Anchor" href="#页目录自映射"></a> 页目录自映射</h2>
<p>[什么是“页表自映射”？ - 知乎 (<a target="_blank" rel="noopener" href="http://zhihu.com">zhihu.com</a>)](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/452598045#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%22%E9%A1%B5%E8%A1%A8%E8%87%AA%E6%98%A0%E5%B0%84%22%EF%BC%9F">https://zhuanlan.zhihu.com/p/452598045#:~:text=什么是&quot;页表自映射&quot;？</a> 学完ICS的我们已经知道，在内存中每个普通的页都有&quot;物理地址&quot;和&quot;虚拟地址&quot;两个地址。 用户程序拿到虚拟地址后，可以把虚拟地址交给MMU，MMU先根据寄存器cr3中的物理地址找到一级页表，再根据虚拟地址的第一部分查询一级页表（也有人称为&quot;页目录%2FPage,Directory&quot; ）得到对应的二级页表（也有人称为&quot;页表%2FPage Table&quot; ）的物理地址，再根据虚拟地址的第二部分查询二级页表得到所需的页的物理地址。)</p>
<p>前文中一级页表和二级页表是物理页，没有规定虚拟地址。但想要通过程序（只能通过虚拟地址）查询页表。</p>
<p>1k*1k=1M</p>
<p>页表没有单独的地址空间（在物理内存中），一个页表项指向自己（首地址是页大小的整数倍）。</p>
<p>Q：指向页表的页表项在哪里？</p>
<p>A：虚拟地址右移12位，得到页号，由于一个页表项4个字节，再左移两位。（不等于右移10位，除非那两位为0！）<img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" /></p>
<p>高10位：一级页目录自映射还是指向自己本身。</p>
<p>再10位：因为指向自己，二级页表项还是那一位。</p>
<p>低12位：页内偏移，因为一个页表项4个字节，左移两位。</p>
<p><img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" /></p>
<ul>
<li>
<p>存储页表的4MB地址空间中是整个4GB虚拟地址空间的一部分，即这4MB在4GB中</p>
</li>
<li>
<p>记录这4MB连续地址空间到物理地址空间的映射关系的是一个4KB的页目录</p>
</li>
<li>
<p>记录这4MB连续地址空间到物理地址空间的映射关系的是一个4KB的页表页(4MB页表中的一员)</p>
</li>
</ul>
<p>所以，页目录和页表页内容相同，页目录无需额外分配单独的存储空间，即有一个4KB的空间可以同时作为页目录和一个页表项，这个4KB的空间表示了整个页表的4MB地址空间与物理地址空间的映射关系。这就是自映射</p>
<blockquote>
<p>第两点的理解：页目录记录着1024个页表页的对应物理页号，而这1024个页表页逻辑连续，就相当于页目录记录了着1024*4KB = 4MB的连续地址空间到物理空间的映射关系；</p>
</blockquote>
<p>自映射：页目录中有一条PDE指向自身物理地址，这个地址就是页目录基址。</p>
<p><code>PT_base</code>：页表基址，<strong>也就是虚拟内存中第一个页表项的地址</strong>，<strong>应与4M对齐</strong>。PT_base=((PT_base)&gt;&gt;22)&lt;&lt;22。</p>
<p><code>PD_base</code>：页目录基址，<code>PD_base</code> = <code>PT_base</code> + <code>PT_base</code> &gt;&gt; 10</p>
<blockquote>
<p>解释：页目录第一个页目录项一定也是记录着第一个页表页的页表项。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>T</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mo>&gt;</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">PT_{base}&gt;&gt;12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>表示第一个页表页的物理页号，一个页表项占4B空间，所以记录第一个页表页的页表项相对页表的偏移为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><msub><mi>T</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mo>&gt;</mo><mn>12</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>2</mn><mo>=</mo><mo stretchy="false">(</mo><mi>P</mi><msub><mi>T</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mo>&gt;</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(PT_{base}&gt;&gt;12)&lt;&lt;2 = (PT_{base}&gt;&gt;10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，可得记录第一个页表页的页表项的地址为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>T</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>+</mo><mi>P</mi><msub><mi>T</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mo>&gt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">PT_{base} + PT_{base}&gt;&gt;10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，这就是页目录第一个页目录项的地址，即页目录基址。</p>
</blockquote>
<p><code>PDE_self_mapping</code>：自映射目录表项， <code>PDE_self_mapping</code> =(<code>PD_base</code>&gt;&gt;12)&lt;&lt;2+<code>PT_base</code>= <code>PT_base</code> + <code>PT_base</code> &gt;&gt; 10 + <code>PT_base</code> &gt;&gt; 20</p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406042129258.png" alt="" style="zoom:80%;" />
<h1 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h1>
<p>程序：静态永久的，存放在磁盘中的可执行文件。</p>
<p>进程：动态暂时的，程序的一次执行过程。（同步一个程序多次执行会对应多个进程。如何区分？每个进程独立的PID;一个进程也可包括多个程序）</p>
<ul>
<li>PCB：进程描述信息（PID，UID），进程控制和管理信息（CPU等使用情况，进程状态），资源分配清单，处理机相关信息记录在进程控制块PCB中。<mark>给os使用</mark></li>
<li>程序段：程序代码（指令序列）。<mark>给进程自身使用</mark></li>
<li>数据段：运行过程中产生的各种数据。 <mark>给进程自身使用</mark></li>
<li><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062110300.png" alt="" /></li>
</ul>
<p><mark>进程是程序的运行过程，是系统进行资源分配和调度的一个独立单位</mark></p>
<p>进程产生过程：</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062110744.png" alt="" /></p>
<h2 id="进程与线程"><a class="markdownIt-Anchor" href="#进程与线程"></a> 进程与线程</h2>
<h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3>
<p><strong>进程特征</strong></p>
<ul>
<li>动态性：进程是程序的一次执行过程。因创建而产生，因撤销而消亡。程序是静态实体。</li>
<li>并发性：多个进程实体同时存在于<mark>内存</mark>中，能在一段时间内同时运行。</li>
<li>独立性：进程是独立运行的基本单位。</li>
<li>异步性：进程之间相互制约，进程以各自独立的不可预知的速度向前推进。</li>
</ul>
<h4 id="进程执行"><a class="markdownIt-Anchor" href="#进程执行"></a> 进程执行</h4>
<h5 id="顺序执行"><a class="markdownIt-Anchor" href="#顺序执行"></a> 顺序执行</h5>
<ul>
<li>顺序性：程序结构所指定的次序。</li>
<li>封闭性：独占全部资源。<strong>执行结果只取决于进程本身，不受外界影响</strong></li>
<li>可再现性：初始条件相同则结果相同。</li>
</ul>
<h5 id="并发-2"><a class="markdownIt-Anchor" href="#并发-2"></a> 并发</h5>
<p>宏观同时发生，微观交替。</p>
<p>间断性：执行-暂停-执行（资源共享，可能被其他程序使用）</p>
<p>非封闭性：多个程序共享系统中资源。<strong>与执行速度有关</strong></p>
<p>不可再现性：结果依赖于执行次序。</p>
<ul>
<li>竞争：多个进程读写一个共享数据。</li>
<li>竞争条件：多个进程并发访问和操作统一数据且执行结果与访问的特定顺序有关。</li>
</ul>
<p>Beernstein条件：</p>
<p><mark>判断程序并发结果是否可再现的充分条件</mark></p>
<p>R(Si）：Si的读子集，其值在Si被引用的变量集合。</p>
<p>W(Si)：Si的写子集, 其值在Si中被改变的变量的集合。</p>
<p>两个进程S1和S2可并发：当且仅当下列条件同时成立：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>S</mi><mn>1</mn><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><mi>S</mi><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">R(S1)\cap W(S2)=\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>S</mi><mn>1</mn><mo stretchy="false">)</mo><mo>∩</mo><mi>R</mi><mo stretchy="false">(</mo><mi>S</mi><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">W(S1)\cap R(S2)=\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>S</mi><mn>1</mn><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><mi>S</mi><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">W(S1)\cap W(S2)=\empty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span></li>
</ul>
<h5 id="并行"><a class="markdownIt-Anchor" href="#并行"></a> 并行</h5>
<p>微观同时发生。</p>
<p>前趋图：表示执行次序。</p>
<h4 id="进程状态与控制"><a class="markdownIt-Anchor" href="#进程状态与控制"></a> 进程状态与控制</h4>
<p>进程控制的主要任务是创建和撤销进程，以及实现进程的状态转换。（内核）</p>
<ul>
<li>创建进程：为进程分配资源，初始化PCB</li>
<li>进程撤销：中止服务，销毁PCB</li>
</ul>
<p>进程的状态：</p>
<ul>
<li>就绪状态：只要分配CPU就可执行。</li>
<li>执行状态：处于此状态的进程数目小于CPU的数目。</li>
<li>阻塞状态：由于某种时间而暂时无法执行，请求等待某个事件发生（发生后，由阻塞态转换为就绪态）。</li>
</ul>
<p><mark>运行态到阻塞态是主动行为，阻塞态到就绪态是被动的，需要相关进程协助</mark></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062111088.png" alt="" /></p>
<p><img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" /></p>
<p>只要就绪队列不空，CPU就总是可以调度进程运行保持繁忙，这和数目无关。除非就绪队列为空，效率降低。</p>
<p><img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" /></p>
<h4 id="进程控制块pcb"><a class="markdownIt-Anchor" href="#进程控制块pcb"></a> 进程控制块PCB</h4>
<p><img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" /></p>
<p>全局变量只与用户代码有关</p>
<blockquote>
<p>正文段：二进制代码，常量，全局变量</p>
<p>堆段：动态分配存储区（malloc）</p>
<p>栈段：局部变量，<strong>函数调用实参传递值</strong></p>
</blockquote>
<h5 id="原语"><a class="markdownIt-Anchor" href="#原语"></a> 原语</h5>
<p>内核中特殊程序，运行不能中断，必须一气呵成（信息不统一，状态标志与所在队列不统一）。</p>
<p>开中断指令和关中断指令配合完成（只能由内核调用）</p>
<p>每个进程都有一个PCB。作用：创建、撤销进程，实现进程状态转换。</p>
<h6 id="创建原语fork"><a class="markdownIt-Anchor" href="#创建原语fork"></a> 创建原语fork</h6>
<ul>
<li>分配进程标识号，申请PCB</li>
<li>分配运行所需的资源（内存，文件…)</li>
<li>初始化PCB</li>
<li>插入到就绪队列中</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062112876.png" alt="" /></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062112942.png" alt="" /></p>
<p><strong>父子进程共享代码段，各自拥有数据段</strong></p>
<p>创建新进程成功，产生两个进程，被调用一次，返回两次。</p>
<ul>
<li><code>&lt;0</code>：err。</li>
<li><code>=0</code>：在子进程中。</li>
<li><code>else</code>：在父进程中，返回子进程pid。</li>
</ul>
<h6 id="撤销原语kill"><a class="markdownIt-Anchor" href="#撤销原语kill"></a> 撤销原语kill</h6>
<p>释放资源，撤销子进程，重新调度。</p>
<ul>
<li>检索出PCB</li>
<li>终止进程执行，如正在运行将处理机资源分配给其他进程</li>
<li><mark>如果还有子孙进程一并终止</mark></li>
<li><mark>将拥有的资源归还给父进程or操作系统</mark></li>
<li>PCB从链表中删除</li>
</ul>
<h5 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062117248.png" alt="" /></p>
<ul>
<li>进程标识符：唯一标识，PID。</li>
<li>程序和数据地址：把PCB与其程序和数据联系起来。</li>
<li>当前状态：相同状态组成队列。</li>
<li>现场保护区：陷入阻塞态时，保存CPU各种状态信息。</li>
<li>同步与互斥机制：实现进程间互斥、同步和通信所需的信号量。</li>
<li>优先级：进程的紧迫程度。</li>
<li>资源清单：处CPU外的资源记录，I/O设备，打开的文件列表。</li>
<li>链接字：队列中下一个进程PCB的首地址。</li>
</ul>
<h5 id="组织方式"><a class="markdownIt-Anchor" href="#组织方式"></a> 组织方式</h5>
<ul>
<li>线性表：不论状态将所有PCB放在内存的系统区。（适用进程数目不多）</li>
<li>链接：按照进程状态组成多个队列，就绪队列、阻塞队列…</li>
<li>索引：线性表的改进，按照状态建立就绪索引表，阻塞索引表…</li>
</ul>
<p><mark><strong>进程上下文切换 vs 陷入内核</strong></mark></p>
<p>进程上下文切换：</p>
<ul>
<li>调度器执行</li>
<li>保存进程执行断点</li>
<li>切换内存映射</li>
<li><strong>只能发生在内核态</strong></li>
</ul>
<p>陷入/退出内核：</p>
<ul>
<li>CPU状态改变</li>
<li>由中断、一行、trap指令（系统调用）引起</li>
<li>保存执行现场（寄存器，堆栈）</li>
<li>寄存器上下文的切换，开销远小于进程上下文切换</li>
</ul>
<h3 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h3>
<p>进程的不足：同一时间只能处理一个任务。</p>
<p>引入线程，<mark>将资源与计算费力，提高并发效率</mark>。线程是基本的CPU执行单元，程序执行流的最小单位，<mark>调度</mark>的基本单位。进程是除CPU之外的<mark>资源分配</mark>的基本单位。</p>
<p>资源拥有者称为进程，可执行单元称为线程。</p>
<ul>
<li>调度的基本单位。</li>
<li>多进程：多个程序并发执行。多线程：并发粒度更细（任务机并行）。</li>
<li>线程间<strong>共享系统资源</strong>。</li>
<li>系统开销：进程间切换进程的运行环境，开销大；线程切换开销小。</li>
<li>有独立的栈区，函数临时变量等。</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062119731.png" alt="" /></p>
<h4 id="线程实现方式"><a class="markdownIt-Anchor" href="#线程实现方式"></a> 线程实现方式</h4>
<h5 id="用户级线程"><a class="markdownIt-Anchor" href="#用户级线程"></a> 用户级线程</h5>
<p>内核中仍然只有进程的概念，线程在用户空间，通过library线程库（实现线程创建、销毁、调度等功能）模拟thread。</p>
<ul>
<li>通过线程库管理线程。</li>
<li>线程切换：线程库应用程序完成，不需要转换到内核态。</li>
<li>os不能意识到用户级线程的存在。</li>
</ul>
<p>优点：用户空间即可完成线程切换，系统开销小。</p>
<p>缺点：其中一个线程被阻塞，整个进程都会被阻塞。并发度并不高。<strong>不能发挥多处理机的优势，内核每次分配给进程仅有一个CPU，仅有一个线程执行</strong></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062121159.png" alt="" /></p>
<h5 id="内核级线程"><a class="markdownIt-Anchor" href="#内核级线程"></a> 内核级线程</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062121527.png" alt="" /></p>
<ul>
<li>内核级线程os内核可感知，用户级线程os内核不可感知。</li>
<li>内核级线程创建、撤销、调度线程均需要内核支持，而用户级依靠线程库。</li>
<li>内核级线程执行系统调用指令，只有该线程中断；用户级所属进程都被中断。</li>
</ul>
<h5 id="混合的线程实现方式"><a class="markdownIt-Anchor" href="#混合的线程实现方式"></a> 混合的线程实现方式</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062122391.png" alt="" /></p>
<ul>
<li>many-to-one Model:多个用户级线程映射到一个内核级线程。
<ul>
<li>优点：线程管理是在用户空间进行的，因而效率比较高。</li>
<li>缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。</li>
</ul>
</li>
<li>one-to-one Model:一个用户级线程映射到一个内核级线程。
<ul>
<li>优点：一个线程被阻塞，别的线程还可以继续执行，并发能力强。</li>
<li>缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大。</li>
</ul>
</li>
<li>many-to-many Model:n个用户级线程映射到m个内核级线程（n&gt;=m）。<mark>只有所有内核级线程都被阻塞才认为进入到了阻塞状态）</mark>
<ul>
<li><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062122528.png" alt="" /></li>
<li>优点：克服了多对一模型并发度不高的缺点，克服了一对一模型中一个用户进程占用多个内核级进程开销太大的缺点。</li>
</ul>
</li>
</ul>
<h4 id="posix-pthreads"><a class="markdownIt-Anchor" href="#posix-pthreads"></a> POSIX Pthreads</h4>
<p>用于线程创建和同步的标准（不只Unix）</p>
<ul>
<li>可在用户级和内核级实现</li>
<li>API规定了线程库的行为，但不限定实现方法</li>
</ul>
<h2 id="同步与互斥"><a class="markdownIt-Anchor" href="#同步与互斥"></a> 同步与互斥</h2>
<p>临界资源：一次仅允许一个进程访问的资源。<mark>互斥共享资源</mark></p>
<p>临界区：每个进程中访问临界资源的那段代码。</p>
<ul>
<li>进程互斥：&gt;=2的进程不能同时进入关于同一组共享资源的临界区。</li>
<li>进程同步（直接制约关系）：各进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。 （各并发进程有序运行）</li>
</ul>
<p><mark>区别与联系：</mark></p>
<p>互斥无法限制访问者对资源的访问顺序，无序访问。同步：对资源的<mark>有序访问</mark>。</p>
<p><strong>临界区管理条件：</strong></p>
<ul>
<li>空闲让进：临界区没有进程时，可进入。</li>
<li>忙则等待：任何两个进程不能同时进入。</li>
<li>有限等待：任何一个进程进入临界区应该在有限时间内得到满足。</li>
<li>让权等待：长时间不能进入临界区，应立即释放处理机，避免忙等。</li>
</ul>
<h3 id="基于忙等待的互斥方法"><a class="markdownIt-Anchor" href="#基于忙等待的互斥方法"></a> 基于忙等待的互斥方法</h3>
<h4 id="软件方法"><a class="markdownIt-Anchor" href="#软件方法"></a> 软件方法</h4>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062132527.png" alt="" /></p>
<p>p执行完while语句后，时间片用完转换到进程q，执行到occupied=true进入临界区，但转到进程p后又临界区的访问，<mark>造成空挡，不能实现互斥</mark></p>
<h5 id="单标志法"><a class="markdownIt-Anchor" href="#单标志法"></a> 单标志法</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062132335.png" alt="" /></p>
<p>可以实现互斥：</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062132657.png" alt="" /></p>
<p>互相谦让，严格两进程交替轮流使用。如果某一个进程一直不使用临界资源，另一个进程也不能使用，违反空闲让进。</p>
<h5 id="双标志检查法"><a class="markdownIt-Anchor" href="#双标志检查法"></a> 双标志检查法</h5>
<p>先上锁，再检查对方是否想要临界区。（检查和上锁不能同步执行）</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062132217.png" alt="" /></p>
<p>竞争时pturn和qturn都为true，都无法进入临界区。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062132274.png" alt="" /></p>
<p>并发运行时，就会同时访问临界区。</p>
<h5 id="dekker算法"><a class="markdownIt-Anchor" href="#dekker算法"></a> Dekker算法</h5>
<p>解决必须严格轮换的问题，通过让权。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062132499.png" alt="" /></p>
<h5 id="peterson算法"><a class="markdownIt-Anchor" href="#peterson算法"></a> Peterson算法</h5>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Pi进程：*/</span>                                       flag[i] = True;</span><br><span class="line"><span class="keyword">while</span>(flag[j]);</span><br><span class="line">critical section;</span><br><span class="line">flag[i] = False;</span><br><span class="line">remainder section; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*Pj进程： */</span>                                         flag[j] = True;</span><br><span class="line"><span class="keyword">while</span>(flag[i]);</span><br><span class="line">critical section;</span><br><span class="line">flag[j] = False;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>如果并发执行，<code>flag[i]</code>和<code>flag[j]</code>都为true，互相谦让饥饿，谁也没进去临界区。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Pi进程：*/</span></span><br><span class="line">flag[i] = True;</span><br><span class="line">turn = j;</span><br><span class="line"><span class="keyword">while</span>(flag[j] &amp;&amp; turn == j);</span><br><span class="line">critical section;</span><br><span class="line">flag[i] = False;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Pj进程：*/</span></span><br><span class="line">flag[j] = True;</span><br><span class="line">turn = i;</span><br><span class="line"><span class="keyword">while</span>(flag[i] &amp;&amp; turn == i);</span><br><span class="line">critical section;</span><br><span class="line">flag[j] = False;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>turn：理解为轮到谁进临界区了（按到达临界区前的先后顺序），<strong>解决饥饿问题</strong></p>
<p>flag：<strong>解决临界资源的互斥访问</strong></p>
<h4 id="硬件方法"><a class="markdownIt-Anchor" href="#硬件方法"></a> 硬件方法</h4>
<h5 id="中断屏蔽方法"><a class="markdownIt-Anchor" href="#中断屏蔽方法"></a> 中断屏蔽方法</h5>
<p>使用开/关中断指令。进入临界区之前执行关中断，退出临界区之前执行开中断。</p>
<p>优点：简单高效。</p>
<p>缺点：不适用多CPU系统。带来性能损失。只适用于<mark>内核进程</mark>，否则用户随意使用开/关中断指令很危险。</p>
<h5 id="test-and-set指令"><a class="markdownIt-Anchor" href="#test-and-set指令"></a> Test and Set指令</h5>
<p>用硬件实现的，执行过程不允许被中断（原语）。把“1”写到某个内存位置并传回其旧值。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062132925.png" alt="" /></p>
<p>缺点：不满足让权等待。</p>
<h5 id="spinlocks自旋锁"><a class="markdownIt-Anchor" href="#spinlocks自旋锁"></a> Spinlocks自旋锁</h5>
<p>利用test_and_set硬件原语提供互斥支持。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">acquire(<span class="keyword">lock</span>)&#123;</span><br><span class="line">	<span class="keyword">while</span>(test_and_set(<span class="keyword">lock</span>)==<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">release(<span class="keyword">lock</span>)&#123;</span><br><span class="line">	<span class="keyword">lock</span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法共性"><a class="markdownIt-Anchor" href="#算法共性"></a> 算法共性</h4>
<p>检查和上锁不能一气呵成。</p>
<p>不满足让权等待。</p>
<p>忙等待：浪费CPU时间</p>
<p>优先级反转：低优先级进程先进入临界区，高优先级一直忙等。</p>
<p>即先启动低优先级进程，加锁后调度高优先级，但判断锁已经为true，导致一直忙等。<mark>是高优先级进程于需要等待低优先级进程所占用的共享资源而被阻塞</mark></p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062133760.png" alt="" style="zoom:80%;" />
<p>解决方案：</p>
<ul>
<li>设置优先级上限：任何进入临界区的进程都获得最高优先级。</li>
<li>优先级集成：当高优先级等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别。</li>
</ul>
<h3 id="基于信号量的同步方法"><a class="markdownIt-Anchor" href="#基于信号量的同步方法"></a> 基于信号量的同步方法</h3>
<p>同步中，进程经常需要等待某个条件的实现，如果使用忙等待，会浪费大量CPU时间。</p>
<p>解决方案：让忙等变为阻塞，原语Sleep和Wakeup。</p>
<h4 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h4>
<p>semaphore（带队列的，不会忙等）</p>
<p>表示某种资源的数量，一个确定的二元组(s, q)，其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列. 当发出P操作时：</p>
<ul>
<li>s为正，则该值等于可立即执行的进程的数量；s &lt;= 0，那么发出P操作后的进程被阻塞，│s │是被阻塞的进程数。</li>
<li>q是一个初始状态为空的队列，当有进程被阻塞时就会进入此队列。</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062135121.png" alt="" /></p>
<p><mark>只能被初始化、P(S)、V(S)操作</mark></p>
<h5 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h5>
<p>二元信号量&amp;一般信号量</p>
<ul>
<li>二元：0/1，实现互斥。</li>
<li>一般：初值为可用物理资源的总数，用于进程间协作同步问题。</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062135159.png" alt="" /></p>
<p>强信号量&amp;弱信号量</p>
<ul>
<li>
<p>强：进程从被阻塞队列释放时采取FIFO</p>
</li>
<li>
<p>弱：没有规定进程从阻塞队列中移除顺序，可能导致饥饿</p>
</li>
</ul>
<p><strong>二元信号量机制</strong></p>
<p>P、V操作成对出现，先做P，进临界区，然后V，出临界区。临界区代码尽可能短，不能死循环。</p>
<p><strong>一般信号量</strong></p>
<p>数据结构包含：初始值为正的整数，初始为空的队列。</p>
<p>三个原子操作：</p>
<ul>
<li>初始化</li>
<li>P：使信号量减1。若值为负（资源分完了），则执行semWait的进程被阻塞</li>
<li>V：使信号量加1。若值小于或等于零（仍有等待该资源的被阻塞），则被semWait操作阻塞的进程被解除阻塞</li>
</ul>
<h5 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062137306.png" alt="" /></p>
<p>PV操作优点：简单，表达能力强（可解决任何同步互斥问题）</p>
<p>缺点：不够安全，使用不当会出现死锁，遇到复杂同步互斥问题时实现复杂</p>
<h6 id="实现进程同步"><a class="markdownIt-Anchor" href="#实现进程同步"></a> 实现进程同步</h6>
<p>P1必须要在P2后执行，可以先初始化信号量为0（前操作之后执行V，后操作之前执行P）</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062137361.png" alt="" /></p>
<h6 id="实现前驱关系"><a class="markdownIt-Anchor" href="#实现前驱关系"></a> 实现前驱关系</h6>
<p>eg：<mark>后驱有两个，设置不同的锁！！！（一次V只能释放一个）</mark></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062137936.png" alt="" /></p>
<p><img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" /></p>
<h6 id="实现进程互斥"><a class="markdownIt-Anchor" href="#实现进程互斥"></a> 实现进程互斥</h6>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">1</span>;</span><br><span class="line">P1()&#123;</span><br><span class="line">    P(S);</span><br><span class="line">    P1临界区;</span><br><span class="line">    V(S);</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">    P(S);</span><br><span class="line">    P2临界区;</span><br><span class="line">    V(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量集"><a class="markdownIt-Anchor" href="#信号量集"></a> 信号量集</h4>
<p>控制同时需要多个资源的互斥访问。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SP(S_1,t_1,d_1,...,)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i\geq t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，否则资源量低，不予分配；占用值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。信号量增减 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<blockquote>
<p>对于信号量集错误的是：（多选）<br />
A. SP(S, d, e)表示每次申请d个资源，当资源数少于e个时，便不予分配</p>
<p>B. SP(S, 0, 1)表示互斥信号量</p>
<p>C. SP(S, 1, 0)当S=0时禁止任何进程进入临界区</p>
</blockquote>
<p>答：A、B</p>
<p>SP(S, d, e)应当表示每次申请e个资源，但当资源数少于d个时便不予分配，A错误。表示互斥信号量的方法是SP(S, 1, 1)，每次申请1个资源，当资源数少于1个时阻塞，B错误。</p>
<h3 id="基于管程的同步与互斥"><a class="markdownIt-Anchor" href="#基于管程的同步与互斥"></a> 基于管程的同步与互斥</h3>
<p>管程：名称，局部与管程内存的共享数据结构的说明，对该数据结构进程操作的一组互斥执行的过程，对局部与管程内部的共享数据设置初始值的语句。</p>
<p><strong>依赖于编译器，适用于单机环境</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor demo&#123;</span><br><span class="line">	共享数据结构 S;</span><br><span class="line">    <span class="keyword">init</span>()&#123;<span class="comment">//初始化</span></span><br><span class="line">        S=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    take_away()&#123;<span class="comment">//申请一个资源</span></span><br><span class="line">        <span class="keyword">if</span>(s&lt;=<span class="number">0</span>)x.wait();</span><br><span class="line">        S--;</span><br><span class="line">    &#125;</span><br><span class="line">    give_back()&#123;<span class="comment">//归还一个资源</span></span><br><span class="line">        S++;</span><br><span class="line">        <span class="keyword">if</span>(有进程在等待)x.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决的问题：</p>
<p>1.互斥：只有一个进程能进入。</p>
<p>2.同步：wait和signal，使一个进程&amp;线程当条件满足/不满足的时候在条件变量上唤醒/等待。</p>
<p>3.条件变量：区分等待的不同原因，每个条件变量保存一个等待队列。</p>
<blockquote>
<p><code>x.wait</code>：当x对应的条件不满足时，调用使该进程进入x条件的等待队列，并释放管程。</p>
<p><code>x.signal</code>：x对应的条件发生变化，调用它唤醒一个因x条件而阻塞的进程。</p>
</blockquote>
<p><strong>与信号量的区别：</strong></p>
<ul>
<li>条件变量的值不可增减（管程中用共享数据结构记录剩余资源数），信号量有值。</li>
<li>wait一定会阻塞当前进程，P操作只有当信号量&lt;0才会阻塞。</li>
<li>如果没有等待的进程，signal将丢失；而V操作增加了信号量的值，不会丢失。</li>
<li>访问条件变量必须拥有管程的锁。</li>
</ul>
<h4 id="hoare管程"><a class="markdownIt-Anchor" href="#hoare管程"></a> Hoare管程</h4>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062140488.png" alt="" /></p>
<p>入口等待队列：管程互斥进入。</p>
<p>紧急等待队列：被其他进程唤醒但由于互斥无法进入管程，优先级高于入口等待队列。</p>
<p>条件变量：每个表示一种等待原因，每个原因对应一个队列。</p>
<p>同步原语wait和signal：针对条件变量x，wait将自己阻塞在x队列中；signal将队列中的一个进程唤醒。</p>
<p><img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" /></p>
<h5 id="信号量定义"><a class="markdownIt-Anchor" href="#信号量定义"></a> 信号量定义</h5>
<ul>
<li>mutex=1：互斥进入管程。进入管程执行<code>P(mutex)</code>，退出管程执行<code>V(mutex)</code>。执行wait由于一定会阻塞该进程，也要<code>V(mutex)</code>。</li>
<li>next=0：发出signal的进程用P挂起自己。进程退出管程前，检查是否有别的进程在next等待，如有用V唤醒。next-count是等待进程数。</li>
<li>x-sem=0：申请资源得不到满足执行P挂起。用x-count记录等待资源的进程数。执行signal时，V。</li>
</ul>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062140737.png" alt="" style="zoom:80%;" />
<h3 id="进程通信的主要方法"><a class="markdownIt-Anchor" href="#进程通信的主要方法"></a> 进程通信的主要方法</h3>
<p>低级通信：只能传递状态和整数值，包括信号量和管程机制。（传送信息量小，编程复杂）</p>
<p>高级通信：适用于分布式系统。包括管道、共享内存、消息系统。</p>
<h4 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h4>
<p>（相当于缓冲区，用于连接一个读进程和一个写进程<mark>读写可同时进行，写满阻塞写，缓冲区为空阻塞读</mark>）</p>
<p>管道是<strong>半双工</strong>的，<strong>数据只能向一个方向流动</strong>。双方通信需要建立两个管道。</p>
<ul>
<li>
<p>无名管道：只能用于父子进程或者兄弟进程之间（亲缘关系）；单独构成一种独立的文件系统，只存在于内存；一个进程向管道中写的内容（添加在缓冲区末尾）被管道另一端的进程读出。</p>
</li>
<li>
<p>有名管道FIFO：不再限制一定有亲缘关系；FIFO不同于无名管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。</p>
</li>
</ul>
<h4 id="消息传递"><a class="markdownIt-Anchor" href="#消息传递"></a> 消息传递</h4>
<p><strong>管程：过度依赖编译器；适用于单机环境</strong></p>
<p>原语：<code>send(destination,&amp;message)</code>和<code>receive(source,&amp;message)</code>。</p>
<p><mark>对用户透明，广泛使用</mark></p>
<h4 id="共享内存"><a class="markdownIt-Anchor" href="#共享内存"></a> 共享内存</h4>
<p>最有用，最快的IPC形式（避免开销巨大的缓冲复制）</p>
<ul>
<li>同一块物理内存被映射到进程A、B各自的进程地址空间。当多个进程共享同一块内存区域，由于共享内存可以同时读但不能同时写，则需要同步机制约束（互斥锁和信号量都可以）。</li>
<li>共享内存可以同时读，不能同时写，需要同步机制约束</li>
<li><mark>通信效率高，进程可以直接读写内存</mark></li>
</ul>
<h3 id="经典进程同步与互斥问题"><a class="markdownIt-Anchor" href="#经典进程同步与互斥问题"></a> 经典进程同步与互斥问题</h3>
<blockquote>
<p>解题：</p>
<ul>
<li>分析同步互斥关系。</li>
<li>同步即先V后P，互斥全部加上PV。</li>
<li>互斥信号量初始值为1，同步要看资源的多少。</li>
</ul>
</blockquote>
<h4 id="生产者-消费者问题"><a class="markdownIt-Anchor" href="#生产者-消费者问题"></a> 生产者-消费者问题</h4>
<p>生产者，消费者，固定大小的缓冲区。</p>
<ul>
<li>同步关系：缓冲区没满-&gt;生产者生产，缓冲区不空-&gt;消费者取数据</li>
<li>互斥关系：各进程互斥访问缓冲区。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥进入缓冲区</span></span><br><span class="line">semaphore empty=n;<span class="comment">//缓冲区空块数</span></span><br><span class="line">semaphore full=<span class="number">0</span>;<span class="comment">//缓冲区满块数</span></span><br><span class="line">producer:&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        put;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer:&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果mutex与empty互换，会被阻塞。<mark>互斥锁尽可能紧靠临界区</mark></p>
<blockquote>
<p>例题：</p>
<p>桌子有一个盘子，只能放一个水果，爸爸只放apple，妈妈只放orange，儿子只吃orange，女儿只吃apple。</p>
<ul>
<li>互斥：爸爸妈妈放水果</li>
<li>同步：爸爸放-女儿拿，妈妈放-儿子拿</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">semaphore plate=<span class="number">1</span>;</span><br><span class="line">semaphore apple=<span class="number">0</span>,orange=<span class="number">0</span>;</span><br><span class="line">dad()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(plate);</span><br><span class="line">        放苹果;</span><br><span class="line">        V(apple);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">mom()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(plate);</span><br><span class="line">        放橘子;</span><br><span class="line">        V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">son()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(orange);</span><br><span class="line">        拿橘子;</span><br><span class="line">        V(plate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(apple);</span><br><span class="line">        拿苹果;</span><br><span class="line">        V(plate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="读者-写者问题"><a class="markdownIt-Anchor" href="#读者-写者问题"></a> 读者-写者问题</h4>
<p>对共享资源的读写操作，任一时刻“写者”只允许一个，“读者”允许多个。读-写互斥，写-写互斥，读-读允许。</p>
<ul>
<li>同步关系：</li>
<li>互斥关系：写与写，写与读</li>
</ul>
<h5 id="读优先"><a class="markdownIt-Anchor" href="#读优先"></a> 读优先</h5>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//互斥访问</span></span><br><span class="line"><span class="built_in">int</span> count=<span class="number">0</span>;<span class="comment">//几个读进程</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//对count互斥访问</span></span><br><span class="line">main()&#123;</span><br><span class="line">    cobegin&#123;</span><br><span class="line">       write:&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">               P(rw);</span><br><span class="line">               write;</span><br><span class="line">               V(rw);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       read:&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">               P(mutex);</span><br><span class="line">               <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">                   P(rw);</span><br><span class="line">               count++;</span><br><span class="line">               V(mutex);</span><br><span class="line">               read;</span><br><span class="line">               P(mutex);</span><br><span class="line">               count--;</span><br><span class="line">               <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">                   V(rw);</span><br><span class="line">               V(mutex);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写与读互斥，两个都加上rw的PV操作。</p>
<p>读与读不互斥：增加count值记录当前有几个读，只有第一次进入读的时候才上锁，最后一个解锁。</p>
<p>读与读同时访问count：给count上锁</p>
<h5 id="读写公平"><a class="markdownIt-Anchor" href="#读写公平"></a> 读写公平</h5>
<p>❓如果读进程一直读，写进程可能会被饿死？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//互斥访问</span></span><br><span class="line">semaphore r=<span class="number">1</span>;<span class="comment">//读写公平</span></span><br><span class="line"><span class="built_in">int</span> count=<span class="number">0</span>;<span class="comment">//几个读进程</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//对count互斥访问</span></span><br><span class="line">main()&#123;</span><br><span class="line">    cobegin&#123;</span><br><span class="line">       write:&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">               P(r);</span><br><span class="line">               P(rw);</span><br><span class="line">               write;</span><br><span class="line">               V(rw);</span><br><span class="line">               V(r);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       read:&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">               P(r);</span><br><span class="line">               P(mutex);</span><br><span class="line">               <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">                   P(rw);</span><br><span class="line">               count++;</span><br><span class="line">               V(mutex);</span><br><span class="line">               V(r);</span><br><span class="line">               read;</span><br><span class="line">               P(mutex);</span><br><span class="line">               count--;</span><br><span class="line">               <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">                   V(rw);</span><br><span class="line">               V(mutex);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加w用于实现读写公平。</p>
<p>读者1-&gt;写者1-&gt;读者2，就会读者2不会继续进入，会被阻塞。</p>
<h5 id="写优先"><a class="markdownIt-Anchor" href="#写优先"></a> 写优先</h5>
<p>要想实现写优先，那么比写先来的读者不能在r上排队。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> readcount=<span class="number">0</span>;<span class="comment">//记录当前有多少个读进程在访问文件</span></span><br><span class="line"><span class="built_in">int</span> writecount=<span class="number">0</span>;<span class="comment">//当writecount=0,唤醒读者</span></span><br><span class="line">semaphore mutex1=<span class="number">1</span>;<span class="comment">//用于保证对readcount变量的互斥访问</span></span><br><span class="line">semaphore mutex2=<span class="number">1</span>;<span class="comment">//用于保证对writecount变量的互斥访问</span></span><br><span class="line"></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//用于保证写者之间的互斥访问，其他读者要进入rmutex之前需要在mutex上排队</span></span><br><span class="line">semaphore rmutex=<span class="number">1</span>;<span class="comment">//当有新写者来时，停止所有的读进程。</span></span><br><span class="line">semaphore wmutex=<span class="number">1</span>;<span class="comment">//实现对写操作地互斥访问</span></span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(mutex);<span class="comment">//实现写者优先访问，禁止读者在rmutex排队,保证一次只有一个读者进程访问rmutex</span></span><br><span class="line">			P(rmutex);<span class="comment">//读者进程加锁</span></span><br><span class="line">				P(mutex1);<span class="comment">//互斥修改readcount变量</span></span><br><span class="line">					readcount++;</span><br><span class="line">					<span class="keyword">if</span>(readcount==<span class="number">1</span>)</span><br><span class="line">						P(wmutex);<span class="comment">//当有读者进程执行读操作时，对写者进程加锁</span></span><br><span class="line">				V(mutex1);</span><br><span class="line">			V(rmutex);<span class="comment">//读者进程解锁</span></span><br><span class="line">		V(mutex);</span><br><span class="line">			读文件...</span><br><span class="line">		P(mutex1);<span class="comment">//互斥修改readcount变量</span></span><br><span class="line">			readcount--;</span><br><span class="line">			<span class="keyword">if</span>(readcount==<span class="number">0</span>)</span><br><span class="line">				V(wmutex);<span class="comment">//当读者数量为0,解锁写者进程，允许写者进程执行写操作</span></span><br><span class="line">		V(mutex1);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">writer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(mutex2);<span class="comment">//各写者进程互斥访问writecount</span></span><br><span class="line">			writecount++;<span class="comment">//写进程数量+1</span></span><br><span class="line">			<span class="keyword">if</span>(writecount==<span class="number">1</span>)</span><br><span class="line">				P(rmutex);<span class="comment">//有写进程时，对读进程加锁</span></span><br><span class="line">		V(mutex2);</span><br><span class="line">		P(wmutex);<span class="comment">//写之前加锁，保证每次只有一个写者可以进行写操作</span></span><br><span class="line">			写文件...</span><br><span class="line">		V(wmutex);</span><br><span class="line">		P(mutex2);</span><br><span class="line">			writecount--;<span class="comment">//每当有一个写进程完成写操作，写者数量-1</span></span><br><span class="line">			<span class="keyword">if</span>(writecount==<span class="number">0</span>)</span><br><span class="line">				V(rmutex);<span class="comment">//若没有写进程正在执行，解锁读者进程</span></span><br><span class="line">		V(mutex2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="哲学家进餐问题"><a class="markdownIt-Anchor" href="#哲学家进餐问题"></a> 哲学家进餐问题</h4>
<p>哲学家思考or进餐，如果进餐，每个哲学家的左边和右边各有一只筷子。需要持有两个临界资源，如果避免造成死锁。</p>
<p>最多只能四个人拿筷子or奇数号拿左边，偶数拿右边or只有两边都可以使用时再抓起筷子。</p>
<blockquote>
<ul>
<li>互斥关系：哲学家与左右邻居对其中间筷子的访问。</li>
<li>注意死锁现象</li>
<li>定义信号量设置。chopsticks[5]={1,1,1,1,1}。左边筷子为i，右边的(i+1)%5.</li>
</ul>
</blockquote>
<h5 id="最多只允许四个哲学家同时尝试进餐破除资源互斥"><a class="markdownIt-Anchor" href="#最多只允许四个哲学家同时尝试进餐破除资源互斥"></a> 最多只允许四个哲学家同时（尝试）进餐——破除资源互斥</h5>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopsticks[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore count=<span class="number">4</span>;<span class="comment">//最多允许4个人</span></span><br><span class="line">Pi()&#123;</span><br><span class="line">    P(count);</span><br><span class="line">    P(chopsticks[i]);</span><br><span class="line">    P(chopsticks[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    吃饭;</span><br><span class="line">    V(chopsticks[i]);</span><br><span class="line">    V[chopsticks[(i+<span class="number">1</span>)%<span class="number">5</span>]];</span><br><span class="line">    V(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="同时拿起两根筷子否则不拿起破除保持等待"><a class="markdownIt-Anchor" href="#同时拿起两根筷子否则不拿起破除保持等待"></a> 同时拿起两根筷子，否则不拿起——破除保持等待</h5>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopsticks[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥的取筷子</span></span><br><span class="line">Pi()&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    P(chopsticks[i]);</span><br><span class="line">    P(chopsticks[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    V(mutex);</span><br><span class="line">    吃饭;</span><br><span class="line">    V(chopsticks[i]);</span><br><span class="line">    V[chopsticks[(i+<span class="number">1</span>)%<span class="number">5</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="奇数号拿左边偶数拿右边"><a class="markdownIt-Anchor" href="#奇数号拿左边偶数拿右边"></a> 奇数号拿左边，偶数拿右边</h5>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopsticks[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">philosopher(<span class="built_in">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            P(chopsticks[i]);</span><br><span class="line">            P(chopsticks[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            P(chopsticks[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">            P(chopsticks[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        吃饭;</span><br><span class="line">        V(chopsticks[i]);</span><br><span class="line">    	V[chopsticks[(i+<span class="number">1</span>)%<span class="number">5</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="睡觉的理发师"><a class="markdownIt-Anchor" href="#睡觉的理发师"></a> 睡觉的理发师</h4>
<p>有一位理发师，一把理发椅，n把等候用的椅子。</p>
<p>与生产者类似，但生产者可以生产无数个，但顾客没有空座就走了</p>
<ul>
<li>互斥：排队的顾客数</li>
<li>同步：顾客唤醒理发师，理发师唤醒下一位等待顾客</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> waiting=<span class="number">0</span>;<span class="comment">//等待的顾客数（不包括正在理发）</span></span><br><span class="line"><span class="built_in">int</span> chairs=n;</span><br><span class="line">semaphore customers=<span class="number">0</span>;<span class="comment">//顾客数</span></span><br><span class="line">semaphore barber=<span class="number">0</span>;<span class="comment">//空闲的理发师数</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥访问waiting</span></span><br><span class="line">barber:&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(customers);</span><br><span class="line">    	P(mutex);</span><br><span class="line">    	waiting--;</span><br><span class="line">    	V(mutex);</span><br><span class="line">    	V(barber);</span><br><span class="line">   	 	cut_hair();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">customer:&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting&lt;chairs)&#123;</span><br><span class="line">        waiting++;</span><br><span class="line">        V(mutex);</span><br><span class="line">    	V(customers);</span><br><span class="line">    	P(barbers);<span class="comment">//理发师忙，顾客坐下等待</span></span><br><span class="line">    	get_haircut();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调度"><a class="markdownIt-Anchor" href="#调度"></a> 调度</h2>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062157494.png" alt="" /></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062157950.png" alt="" /></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062157841.png" alt="" /></p>
<p>CPU调度：控制、协调多个进程对CPU的竞争。</p>
<blockquote>
<ul>
<li>进程调度算法</li>
<li>进程调度的时机</li>
<li>CPU切换过程（进程的上下文切换）</li>
</ul>
</blockquote>
<h3 id="cpu三级调度"><a class="markdownIt-Anchor" href="#cpu三级调度"></a> CPU三级调度</h3>
<ul>
<li>
<p>高级调度（作业）：（用户角度）一次提交若干作业，对每个作业进行调度。<strong>从外存后备队列挑选一个使其获得竞争CPU的权利</strong></p>
</li>
<li>
<p>中级调度（内外存交换）：指令和数据必须在内存里才能被CPU直接访问。（存储器资源管理角度）进程的部分或全部换出到外存，当前所需部分换入到内存。<strong>将内存中暂时不能运行的调出到外存等待（挂起态），具备条件后再调入内存（就绪态）</strong></p>
</li>
<li>
<p>低级调度（进程&amp;线程调度）：（CPU资源管理角度）执行单位ms。<strong>高效率</strong></p>
</li>
</ul>
<p>调度频率：低级&gt;中级&gt;高级</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406051627287.png" alt="" /></p>
<h3 id="调度准则"><a class="markdownIt-Anchor" href="#调度准则"></a> 调度准则</h3>
<blockquote>
<p>不同角度判断处理机调度算法的性能</p>
</blockquote>
<ul>
<li>
<p><strong>周转时间</strong>：作业从提交到完成经理时间=收容队列等待+CPU执行+就绪、阻塞等待+结果输出等待（批处理系统）</p>
</li>
<li>
<p><strong>带权平均周转时间</strong>：周转时间/实际服务时间</p>
</li>
<li>
<p>响应时间：用户输入请求到系统给出首次响应（分时系统）</p>
</li>
<li>
<p>截止时间：开始截止时间和完成截止时间（实时系统，与周转时间类似）</p>
</li>
<li>
<p>优先级：使关键任务达到更好的指标</p>
</li>
<li>
<p>公平性：不因作业或进程本身的特性使上述指标过分恶化（eg：长作业等待时间极长）</p>
</li>
<li>
<p><strong>吞吐量</strong>：单位时间内完成作业数</p>
<blockquote>
<p>平均周转时间不一定是吞吐量的倒数。并发执行作业时间可重叠⚠️</p>
</blockquote>
</li>
<li>
<p>处理机利用率</p>
</li>
<li>
<p>各种资源的均衡利用：CPU繁忙的和作业和I/O繁忙（次数多，时间短）的作业搭配</p>
</li>
</ul>
<p><mark>易于实现，执行/开销比小</mark></p>
<h3 id="设计调度算法考虑问题"><a class="markdownIt-Anchor" href="#设计调度算法考虑问题"></a> 设计调度算法考虑问题</h3>
<h5 id="进程优先级数"><a class="markdownIt-Anchor" href="#进程优先级数"></a> 进程优先级（数）</h5>
<p>优先级：进程重要性和紧迫性。优先数：数值反应优先级</p>
<p>静态优先级&amp;动态</p>
<h5 id="进程就绪队列组织"><a class="markdownIt-Anchor" href="#进程就绪队列组织"></a> 进程就绪队列组织</h5>
<p>按优先级：优先级较高先执行</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062204202.png" alt="" /></p>
<p>所有进程创建都进入第一级就绪队列，随着进程运行，降低某些进程的优先级，进入之后级的队列。（比如时间片用完）</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062204115.png" alt="" /></p>
<h5 id="占用cpu方式"><a class="markdownIt-Anchor" href="#占用cpu方式"></a> 占用CPU方式</h5>
<ul>
<li>不可抢占式：一旦分配进程一直占用处理机，除非进入阻塞&amp;时间片用完</li>
<li>抢占式：一旦有优先级高于当前进程优先级，立即进程调度</li>
</ul>
<h5 id="进程分类"><a class="markdownIt-Anchor" href="#进程分类"></a> 进程分类</h5>
<ul>
<li>
<p>I/O密集型&amp;CPU密集型</p>
</li>
<li>
<p>批处理进程（无需用户交互，无需马上响应）&amp;交互式进程（交互平凡，响应时间快）&amp;实时进程（实时要求，不能被低优先级阻塞，响应时间短）</p>
</li>
</ul>
<h5 id="时间片"><a class="markdownIt-Anchor" href="#时间片"></a> 时间片</h5>
<p>分配给占用CPU的长度，确定允许该进程运行的时间长度</p>
<h3 id="批处理系统的调度算法"><a class="markdownIt-Anchor" href="#批处理系统的调度算法"></a> 批处理系统的调度算法</h3>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406051630774.png" alt="" /></p>
<h4 id="先来先服务fcfs"><a class="markdownIt-Anchor" href="#先来先服务fcfs"></a> 先来先服务FCFS</h4>
<p>按照作业提交或进程变为就绪状态的先后次序，非抢占式，I/O完成并不立即恢复执行。</p>
<p>利于长作业，利于CPU繁忙的作业</p>
<blockquote>
<p>Q：有利于CPU繁忙的作业，不利于I/O繁忙的作业。why？</p>
<p>A：FCFS在CPU繁忙的作业到达时，可以立即执行，一直占用CPU资源直到完成。当I/O繁忙的作业，每运行一点点就因为I/O而被阻塞，返回就绪状态后又返回到了队列的队尾，I/O繁忙型作业响应时间长。</p>
<p><mark><strong>延伸</strong></mark>：I/O型进程比计算型优先级高，I/O设备可以和CPU并行工作，优先的话可以使其今早投入工作，以提升吞吐量。</p>
</blockquote>
<h4 id="短作业优先sjf"><a class="markdownIt-Anchor" href="#短作业优先sjf"></a> 短作业优先SJF</h4>
<p>对FCFS改进，减少平均周转时间，非抢占</p>
<p>优：缩短作业等待时间，提升吞吐量</p>
<p>缺：不利于长作业，不划分优先级，难以估计作业的执行时间</p>
<h4 id="最短剩余时间优先srtn"><a class="markdownIt-Anchor" href="#最短剩余时间优先srtn"></a> 最短剩余时间优先SRTN</h4>
<p>SJF改进为抢占式</p>
<p>缺：长作业饥饿</p>
<h4 id="最高响应时间比优先hrrn"><a class="markdownIt-Anchor" href="#最高响应时间比优先hrrn"></a> 最高响应时间比优先HRRN</h4>
<p>FCFS和SJF折中，非抢占，调度时先计算每个作业响应比RP，选择值最大的。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="normal">作</mi><mi mathvariant="normal">业</mi><mi mathvariant="normal">已</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">待</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>+</mo><mi mathvariant="normal">作</mi><mi mathvariant="normal">业</mi><mi mathvariant="normal">服</mi><mi mathvariant="normal">务</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">业</mi><mi mathvariant="normal">服</mi><mi mathvariant="normal">务</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">作</mi><mi mathvariant="normal">业</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">待</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">业</mi><mi mathvariant="normal">服</mi><mi mathvariant="normal">务</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow><annotation encoding="application/x-tex">RP=(作业已等待时间+作业服务时间)/作业服务时间=1+作业等待时间/作业服务时间
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">待</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mclose">)</span><span class="mord">/</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">待</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord">/</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span></span></p>
<p>优：短作业容易获得较高响应比，长作业等待时间长后也可以得到高响应比。</p>
<p>缺：计算RP时间开销。</p>
<h3 id="交互式系统的调度算法"><a class="markdownIt-Anchor" href="#交互式系统的调度算法"></a> 交互式系统的调度算法</h3>
<h4 id="时间片轮转rr"><a class="markdownIt-Anchor" href="#时间片轮转rr"></a> 时间片轮转RR</h4>
<p><mark>一定是可抢占</mark></p>
<p>提高进程并发性和响应时间特性，从而提高资源利用率。</p>
<blockquote>
<p>按FCFS排成队列，执行一个时间片后暂停，送到就绪队列末尾，通过上下文切换到队首进程。</p>
</blockquote>
<ul>
<li>时间片过长：退化为FCFS，进程在一个时间片内部即可执行完，响应时间长。</li>
<li>过短：上下文切换次数增加，响应时间长。</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi mathvariant="normal">响</mi><mi mathvariant="normal">应</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi><mo stretchy="false">(</mo><mi mathvariant="normal">进</mi><mi mathvariant="normal">程</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">目</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>q</mi><mo stretchy="false">(</mo><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">片</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(响应时间)=N(进程数目)*q(时间片)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord cjk_fallback">响</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">目</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">片</span><span class="mclose">)</span></span></span></span></span></p>
<p>就绪进程数目越多，时间片越小。通常用户输入在一个时间片内处理完。</p>
<h4 id="优先级算法ps"><a class="markdownIt-Anchor" href="#优先级算法ps"></a> 优先级算法PS</h4>
<p>平衡各进程对响应时间的要求。</p>
<p>抢占&amp;非抢占：</p>
<ul>
<li>抢占：出现更高优先级的进程进入就绪队列，立即调度</li>
<li>非抢占：继续执行</li>
</ul>
<p>静态&amp;动态：</p>
<ul>
<li>
<p>静态：依据进程类型，对资源需求，用户要求</p>
</li>
<li>
<p>动态：等待时间长调高优先级，每执行一个时间片降低优先级。</p>
</li>
</ul>
<h4 id="多级队列mq"><a class="markdownIt-Anchor" href="#多级队列mq"></a> 多级队列MQ</h4>
<blockquote>
<p>引入多个就绪队列，区别对待各列（进程兴致或类型不同），每个作业固定归入一个队列。</p>
</blockquote>
<h4 id="多级反馈队列mfq"><a class="markdownIt-Anchor" href="#多级反馈队列mfq"></a> 多级反馈队列MFQ</h4>
<p>时间片轮转&amp;优先级算法</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062204732.png" alt="" /></p>
<h5 id="线程调度一个时间片内的调度"><a class="markdownIt-Anchor" href="#线程调度一个时间片内的调度"></a> 线程调度：一个时间片内的调度</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062204564.png" alt="" /></p>
<h5 id="优先级倒置"><a class="markdownIt-Anchor" href="#优先级倒置"></a> 优先级倒置</h5>
<p>低优先级的进程占用临界资源且被阻塞，且低优先级的很长时间得不到CPU进而间接导致同样需要使用临界资源的高优先级进程被阻塞。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062204976.png" alt="" /></p>
<p>解决方法：优先级置顶。</p>
<blockquote>
<p>进入临界区，当前执行进程具有最高优先级</p>
</blockquote>
<p>解决方法：优先级进程。</p>
<blockquote>
<p>高优先级进入临界区，发现已经有低优先级进程，则其继承高优先级。</p>
</blockquote>
<h3 id="实时系统的调度算法"><a class="markdownIt-Anchor" href="#实时系统的调度算法"></a> 实时系统的调度算法</h3>
<p>时间起主导作用，硬实时（对时间必须响应）&amp;软实时（偶尔可不满足）。<strong>进程行为可预测</strong></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062204692.png" alt="" /></p>
<h4 id="静态表调度"><a class="markdownIt-Anchor" href="#静态表调度"></a> 静态表调度</h4>
<blockquote>
<p>对所有周期性任务分析预测，确定固定的调度方案。</p>
</blockquote>
<p>优：无计算，开销小。</p>
<p>缺：无灵活性，适用固定场景。</p>
<h4 id="单调速率调度rms"><a class="markdownIt-Anchor" href="#单调速率调度rms"></a> 单调速率调度RMS</h4>
<blockquote>
<p>周期越小，优先级越高。</p>
</blockquote>
<p>任务集可调度：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub></mfrac><mo>≤</mo><mi>n</mi><mo stretchy="false">(</mo><mroot><mn>2</mn><mi>n</mi></mroot><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>≈</mo><mn>0.69</mn></mrow><annotation encoding="application/x-tex">\sum^{n}_{i=1}\frac{C_i}{T_i}\leq n(\sqrt[n]{2}-1)\approx0.69
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.206095em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738594em;"><span style="top:-3.023314em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.956095em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.916095em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08390500000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">9</span></span></span></span></span></p>
<h4 id="最早时间优先算法edf"><a class="markdownIt-Anchor" href="#最早时间优先算法edf"></a> 最早时间优先算法EDF</h4>
<blockquote>
<p>绝对截止日期时间最早，优先级越高</p>
</blockquote>
<p>任务集可调度：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub></mfrac><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum^n_{i=1}\frac{C_i}{T_i}\leq1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<h4 id="最低松弛度优先算法llf"><a class="markdownIt-Anchor" href="#最低松弛度优先算法llf"></a> 最低松弛度优先算法LLF</h4>
<blockquote>
<p>根据任务紧急程度确定优先级。</p>
<p>调度时机（抢占）：有进程执行完&amp;进程laxity=0（抢占）</p>
</blockquote>
<p>松弛度=任务截止时间-本身剩余运行时间-当前时间</p>
<p>任务集可调度：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub></mfrac><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum^n_{i=1}\frac{C_i}{T_i}\leq1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<h3 id="多处理机调度"><a class="markdownIt-Anchor" href="#多处理机调度"></a> 多处理机调度</h3>
<p>注重整体效率，多样调度算法，调度范围线程</p>
<h4 id="非对称式amp"><a class="markdownIt-Anchor" href="#非对称式amp"></a> 非对称式AMP</h4>
<p>各个处理器的地位不同，有固定分工。</p>
<h4 id="对称式smp"><a class="markdownIt-Anchor" href="#对称式smp"></a> 对称式SMP</h4>
<p>地位相同。</p>
<h5 id="静态控制"><a class="markdownIt-Anchor" href="#静态控制"></a> 静态控制</h5>
<p>每个CPU设立一个就绪队列，进程从执行到完成，都在同一个CPU上。</p>
<ul>
<li>优：调度算法开销小</li>
<li>缺：容易出现忙闲不均</li>
</ul>
<h5 id="动态控制"><a class="markdownIt-Anchor" href="#动态控制"></a> 动态控制</h5>
<p>各个CPU采用公共就绪队列，选择队首分配给空闲CPU</p>
<ul>
<li>自调度：各个CPU采用公共就绪队列，每个处理机都可以从队列中选择适当进程来执行。
<ul>
<li>优：不需要专门处理机任务分派</li>
<li>缺：处理机个数多，对就绪队列的访问有问题</li>
</ul>
</li>
<li>成组调度：将一个进程中的一组线程，每次同时分派到一组处理机上执行，在剥夺处理机时也同时对这一组线程进行。</li>
<li>专用处理机调度：每个线程分配一个CPU</li>
</ul>
<h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2>
<p>每个进程无限等待组内其他进程所占有的资源。</p>
<p>原因：资源竞争，并发执行的顺序不当。</p>
<ul>
<li>可剥夺资源：获得后还可被其他进程或系统剥夺（CPU，内存）</li>
<li>非可剥夺资源：分配后不能强行收回，只能自行释放（打印机）</li>
<li>临时性资源：一个进程产生，被另一个进程使用，短时间后便无用（消息）</li>
</ul>
<p><mark>必要条件</mark></p>
<blockquote>
<ul>
<li>互斥：进程对分配到的资源进行排他性使用。</li>
<li>请求和保持：进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但仍占有已获得的资源。</li>
<li>不可剥夺：已获得的资源未使用前不能被剥夺，只能使用完自己释放。</li>
<li>环路等待：必然存在一个进程—资源的环形链，循环等待。</li>
</ul>
</blockquote>
<p><strong>活锁和饥饿</strong></p>
<ul>
<li>
<p>活锁：任务没有被阻塞，由于某些条件没有满足导致重复尝试。</p>
<blockquote>
<p>与死锁区别：处于活锁的实体是在不断地改变状态，而处于死锁的实体表现为等待。活锁可能自行打开。避免：先来先服务</p>
</blockquote>
</li>
<li>
<p>饥饿：资源分配策略的不公平导致长时间等待。</p>
</li>
</ul>
<p><strong>允许死锁发生：鸵鸟算法</strong></p>
<h3 id="死锁预防静态"><a class="markdownIt-Anchor" href="#死锁预防静态"></a> 死锁预防（静态）</h3>
<ul>
<li>
<p>打破互斥条件：允许进程同时访问某些资源。</p>
</li>
<li>
<p>打破请求且保持条件：实行资源预先分配策略。只有满足当前进程全部资源才能够一次性分配所申请的资源。</p>
<blockquote>
<p>缺点：有些进程动态不可预测；资源利用率低；降低并发性</p>
</blockquote>
</li>
<li>
<p>打破不可剥夺条件：允许进程强行从占有者那里夺取某些资源</p>
<blockquote>
<p>缺点：降低系统性能</p>
</blockquote>
</li>
<li>
<p>打破循环等待条件：实行资源有序分配策略，将资源事先分类标号，按号分配。<mark>将资源实现编号，只有占有了小号资源才能申请大号</mark></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062206880.png" alt="" /></p>
<blockquote>
<p>缺点：限制进程对资源的请求，对系统中所有资源合理编号也复杂，增加系统开销；暂不使用的资源也要提前申请，增加进程对资源的占用时间。</p>
</blockquote>
</li>
</ul>
<h3 id="死锁避免动态"><a class="markdownIt-Anchor" href="#死锁避免动态"></a> 死锁避免（动态）</h3>
<p>安全序列：对于每一个进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，他需要的资源可以被系统中当前可用资源加上所有进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_j(j&lt;i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>当前占有资源之和满足。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062206751.png" alt="" /></p>
<h4 id="银行家算法"><a class="markdownIt-Anchor" href="#银行家算法"></a> 银行家算法</h4>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062206989.png" alt="" /></p>
<p>如果work大于等于需要，就可以finish。</p>
<h4 id="资源分配图"><a class="markdownIt-Anchor" href="#资源分配图"></a> 资源分配图</h4>
<img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" style="zoom:80%;" />
<h5 id="rag算法"><a class="markdownIt-Anchor" href="#rag算法"></a> RAG算法</h5>
<p>封锁进程：某个进程由于请求了超过系统中现有的未分配资源数目资源，而被系统封锁的进程。</p>
<p>未封锁进程：没有被进程封锁的进程。</p>
<p>化简：未封锁进程，将请求边变成分配边，一段时间后资源全部释放。直到所有进程变成孤立点。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_41774120/article/details/101998375">操作系统------资源分配图化简-CSDN博客</a></p>
<ul>
<li>计算出所有资源的空闲量：总数-出度</li>
<li>看每个进程：如果请求边&lt;=资源空闲量，删去所有边</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062206478.png" alt="" /></p>
<h3 id="死锁解除"><a class="markdownIt-Anchor" href="#死锁解除"></a> 死锁解除</h3>
<ul>
<li>剥夺资源：使用挂起/激活挂起一些进程，剥夺他们的资源以解除死锁，条件满足后再激活进程。</li>
<li>撤销进程：使全部死锁的进程夭折；按照某种顺序逐个撤销（回退）进程，直至有足够的资源可用，死锁状态消除。</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062206485.png" alt="" /></p>
<h1 id="io管理"><a class="markdownIt-Anchor" href="#io管理"></a> I/O管理</h1>
<p>目的：提高I/O访问效率，方便用户使用，方便对设备的控制。</p>
<p>功能：提供用户接口（命令&amp;编程）；设备分配和释放；设备的访问和控制；I/O缓冲和调度。</p>
<p>总线：数据线，地址线，控制线（接入I/O设备主要方式）</p>
<h2 id="io管理概述"><a class="markdownIt-Anchor" href="#io管理概述"></a> I/O管理概述</h2>
<h3 id="软件角度"><a class="markdownIt-Anchor" href="#软件角度"></a> 软件角度</h3>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062207013.png" alt="" /></p>
<p>I/O设备管理可直接从应用程序或文件系统得到请求并负责完成这个请求。包括：</p>
<ul>
<li>逻辑I/O：完成设备无关的操作，设备分配、回收，数据准备</li>
<li>设备驱动程序：负责对设备控制器进行控制（读写寄存器）</li>
<li>中断服务程序：设备工作结束后负责向CPU发中断信号</li>
</ul>
<p>特点：速度差异大，接口复杂，传输单位不同，错误多样，与文件系统及其他功能联系紧密</p>
<h3 id="分类-2"><a class="markdownIt-Anchor" href="#分类-2"></a> 分类</h3>
<p><strong>按数据组织</strong></p>
<blockquote>
<ul>
<li>块设备：以数据块为单位存储，传输信息。传输效率高，可寻址（随机读写）</li>
<li>字符设备：以字符为单位存储。传输效率低，不可寻址。</li>
</ul>
</blockquote>
<p><strong>按用途分类</strong></p>
<blockquote>
<ul>
<li>存储设备：磁盘，磁带。</li>
<li>传输设备：网卡，Modem。</li>
<li>人机交互设备：显示器，键盘，鼠标。</li>
</ul>
</blockquote>
<p><strong>资源分配角度</strong></p>
<blockquote>
<ul>
<li>独占设备：只能由一个进程使用的设备（打印机）</li>
<li>共享设备：允许多个进程共同使用（硬盘）</li>
<li>虚设备：在一类设备上模拟另一类设备，用共享设备模拟独占设备，用高速设备模拟低速设备。</li>
</ul>
</blockquote>
<h3 id="io管理目标和任务"><a class="markdownIt-Anchor" href="#io管理目标和任务"></a> I/O管理目标和任务</h3>
<blockquote>
<p>1.按照用户请求，控制设备操作，完成I/O设备与内存间的数据交换，最终完成用户的I/O请求。</p>
</blockquote>
<ul>
<li>设备的分配与回收：记录设备状态；根据用户的请求和设备的类型，采用一定的分配算法，选择一条数据通路。</li>
<li>执行设备驱动程序，实现真正的I/O操作。</li>
<li>设备中断处理：处理外部设备的中断。</li>
<li>缓冲区管理：管理不同的I/O缓冲区。</li>
</ul>
<blockquote>
<p>2.建立方便、统一的独立于设备的接口。</p>
</blockquote>
<ul>
<li>方便性：向用户提供易于使用的外部设备接口。</li>
<li>统一性：对不同的设备采用统一的操作方式，即在用户程序中使用逻辑设备（对物理设别的抽象，屏蔽物理硬件的细节）</li>
</ul>
<blockquote>
<p>3.充分利用各种技术提高CPU与设备、设备与设备之间的并行工作能力，充分利用资源。由于CPU与I/O间的速度差异很大，应尽可能减少速度差异造成的整体性能开销，尽可能使CPU与设备都处于充分忙碌状态。</p>
</blockquote>
<blockquote>
<p>4.保护：设备传送或管理的数据应该是安全的、 不被破坏的、保密的。</p>
</blockquote>
<h2 id="io硬件组成"><a class="markdownIt-Anchor" href="#io硬件组成"></a> I/O硬件组成</h2>
<p>I/O设备由机械部件和电子部件（设备控制器：<font color='orange'><strong>是硬件</strong></font>）组成</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062207855.png" alt="" /></p>
<h3 id="设备控制器"><a class="markdownIt-Anchor" href="#设备控制器"></a> 设备控制器</h3>
<p>CPU与I/O设备的中介，实现CPU对I/O设备的控制</p>
<h4 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h4>
<ul>
<li>接收和识别CPU命令（控制寄存器：存放命令和参数read&amp;write）</li>
<li>数据交换：CPU与控制器</li>
<li>设备状态的了解和报告（状态寄存器）</li>
<li>数据交换（数据寄存器）</li>
<li>设备地址识别（判断读写哪个寄存器）</li>
<li>缓冲区</li>
<li>对设备传来的数据进行差错检测</li>
</ul>
<h4 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h4>
<ul>
<li>控制器与CPU接口：数据寄存器、控制寄存器、状态寄存器</li>
<li>控制器与设备接口：数据信号、控制信号、状态信号</li>
<li>I/O逻辑：用于实现CPU对I/O设备的控制</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062207865.png" alt="" /></p>
<p><strong>可能对应多个设备，寄存器可能对应也有多个。如何编址？</strong></p>
<ul>
<li>
<p>内存映射I/O（MIPS）：<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406061031228.png" alt="" style="zoom:67%;" /></p>
<p>寄存器与内存地址统一编址</p>
<ul>
<li>优点：不需要特殊的保护机制来阻止用户进程进行相应的 I/O 操作</li>
<li>缺点：不能对控制寄存器的内容进行高速缓存</li>
</ul>
</li>
<li>
<p>I/O独立编址：<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406061033245.png" alt="" /></p>
<p>控制器中的寄存器使用单独的地址</p>
<ul>
<li>优点：外设不占用内存的地址空间，以区分对内存操作还是I/O操作</li>
<li>缺点：操作指令类型少，操作不灵活</li>
</ul>
</li>
</ul>
<h2 id="io控制技术"><a class="markdownIt-Anchor" href="#io控制技术"></a> I/O控制技术</h2>
<h3 id="程序控制io"><a class="markdownIt-Anchor" href="#程序控制io"></a> 程序控制I/O</h3>
<p>由CPU代表进程向I/O模块发出指令，然后进入忙等状态，直到操作完成之后进程才能够继续执行。</p>
<p>CPU:开始发送指令，不断轮询检查状态，完成后传入内存</p>
<p>数据传送单位：字</p>
<p>优点：实现简单</p>
<p><strong>缺点：CPU与I/O只能串行工作，I/O工作时，CPU忙等轮询检查，CPU效率低</strong></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062208470.png" alt="" /></p>
<ul>
<li>应用程序提出读数据请求</li>
<li>设备驱动程序检查设备的状态</li>
<li>如果状态正常，给设备发出响应的控制命令</li>
<li>不断轮询检查是否完成执行过程</li>
<li>设备控制器完成操作，把数据送给应用程序</li>
<li>应用程序继续进行相应的处理</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062208039.png" alt="" /></p>
<h3 id="中断驱动方式"><a class="markdownIt-Anchor" href="#中断驱动方式"></a> 中断驱动方式</h3>
<p>当I/O操作结束后设备控制器主动的来通知设备驱动程序，而不是依靠设备驱动程序不断轮询查看设备的状态</p>
<p>CPU：开始时发出I/O指令，然后阻塞该进程，继续运行进程，直至接受中断指令，完成后处理中断。</p>
<p>数据传送单位：字（一次中断传送一字）</p>
<p>优点：实现CPU与I/O并行工作</p>
<p>缺点：每次传送一个字，频繁中断处理消耗CPU很多时间</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062208145.png" alt="" /></p>
<ul>
<li>用户程序提出I/O请求</li>
<li>设备驱动程序检查设备的状态</li>
<li>如果设备准备好，就向设备发出控制命令</li>
<li>将状态记录在设备状态表中，CPU继续其他工作</li>
<li>设备完成工作后向CPU发中断信号，转入中断处理程序</li>
<li>中断处理程序发现这是一个正常的完成了控制命令的信号后，把结果转发给设备管理程序</li>
<li>设别管理程序从设备状态表里查询是哪个请求的完成</li>
<li>把相应数据送到应用程序</li>
<li>通知应用程序可以继续执行</li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062208840.png" alt="" /></p>
<h3 id="dma"><a class="markdownIt-Anchor" href="#dma"></a> DMA</h3>
<p>直接存储器访问方式，由一个专门的控制器来完成数据从内存到设备或者是从设备到内存的传输工作.</p>
<ul>
<li>由程序设置DMA控制器中的若干寄存器值（如内存始址、传送字节数），然后发起I/O操作</li>
<li>DMA控制器完成内存与外设的成批数据交换</li>
<li>在操作完成时由DMA控制器向CPU发出中断</li>
</ul>
<p><strong>寄存器</strong></p>
<ul>
<li>命令/状态寄存器CR：接收CPU发送来的I/O命令</li>
<li>内存地址寄存器MAR：输入——把数据从设备传送到内存的起始目标地址，输出——存放由内存到设备的内存源地址</li>
<li>数据寄存器DR：暂存从设备到内存，或从内存到设备</li>
<li>数据计数器DC：存放本次CPU要读或写的字节数</li>
</ul>
<p>优点：CPU只需干预I/O操作的开始和结束，而后续成批的数据读写无需CPU控制，使用<mark>高速设备</mark></p>
<p>缺点：数据传送方向，存放数据的内存及传送数据的长度由CPU控制</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406022105890.png" alt="" /></p>
<blockquote>
<p>与中断方式的区别：</p>
<ul>
<li>中断每个单位数据传送完成中断CPU，DMA传送一批数据完成后中断CPU</li>
<li>中断数据传送由CPU完成，DMA由DMA控制器完成，只有开始和结束需要CPU干预</li>
<li>中断具有对异常事件的处理能力，DMA控制方式适用于数据块的传输</li>
</ul>
</blockquote>
<p>数据传送单位：块（读入内存也要连续！）</p>
<p>数据流向：可以直接从设备放入内存&amp;内存到设备</p>
<p><strong>只需要在传送开始和结束才需要CPU干预</strong></p>
<h3 id="io通道"><a class="markdownIt-Anchor" href="#io通道"></a> I/O通道</h3>
<p><strong>进一步减少CPU的干预</strong></p>
<p><strong>CPU：向通道发出I/O指令，指明通道程序的内存位置，要操作的I/O设备，然后就切换进程</strong></p>
<p>与DMA原理几乎一样。I/O通道专门负责数据输入输出的传输控制。CPU将“传输控制”的功能下放给通道后只负责“数据处理”功能。这样，通道与CPU分时使用内存 ，实现了CPU内部运算与I/O设备的并行工作。</p>
<p>优点：执行一个通道程序可以完成几组I/O操作，与DMA相比，减少了CPU干预</p>
<p>缺点：费用高</p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406022133674.png" alt="" style="zoom:50%;" />
<ul>
<li>字节多路通道：以字节为单位交叉工作，<mark>中低速I/O设备</mark></li>
<li>数组选择通道：以“组方式”工作，每次传输一批数据，速率高，但一段时间只能为一台设备服务。<mark>连接磁盘、磁带等高速设备</mark></li>
<li>数组多路通道：洁亮两者特点。对通道程序采用多道程序设计技术，使得与通道连接的设备可以并行工作</li>
</ul>
<blockquote>
<p>与DMA区别：</p>
<ul>
<li>DMA方式下数据传送方向，存放数据的内存及传送数据的长度由CPU控制；而通道通过执行通道程序实现对数据传输的控制，更强的独立处理I/O功能</li>
<li>DMA只能控制一台&amp;少数同类设备；通道同时控制多种设备</li>
</ul>
</blockquote>
<h2 id="io软件组成"><a class="markdownIt-Anchor" href="#io软件组成"></a> I/O软件组成</h2>
<h3 id="分层设计思想"><a class="markdownIt-Anchor" href="#分层设计思想"></a> 分层设计思想</h3>
<blockquote>
<p>软件组织成多个层次，每层实现一部分功能，依赖更低一层的原始功能，从而隐藏功能细节；给高一层提供服务。</p>
<p>低层考虑硬件特性，向高层软件提供接口；高层不依赖于硬件，向用户提供友好接口。</p>
</blockquote>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062209378.png" alt="" /></p>
<ul>
<li>用户性软件通过“系统调用”请求操作系统内核的服务。</li>
<li>设备独立性软件：处理系统调用（向上处理接口），对设备的保护，差错处理，设备的分配与回收，映射关系逻辑设备表（逻辑设备——物理设备），缓冲区管理</li>
<li>设备驱动程序：自动配置和初始化子程序，I/O操作子程序，中断服务子程序</li>
</ul>
<h3 id="设备独立性"><a class="markdownIt-Anchor" href="#设备独立性"></a> 设备独立性</h3>
<p>逻辑设备——物理设备</p>
<blockquote>
<p>使用逻辑设备名称来请求使用某类设备，而系统在实际执行时，还必须使用物理设备名称。 （所以系统需具有逻辑设备名称转换为物理设备名称的功能）</p>
</blockquote>
<ul>
<li>设备分配的灵活性：直接使用物理名称容易阻塞；逻辑名称可分配给同类设备</li>
<li>易于实现I/O重定向：设备更换不必改变应用程序</li>
</ul>
<h4 id="逻辑设备名到物理设备名的映射"><a class="markdownIt-Anchor" href="#逻辑设备名到物理设备名的映射"></a> 逻辑设备名到物理设备名的映射</h4>
<p>逻辑设备表LUT</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031006394.png" alt="" /></p>
<ul>
<li>整个系统设置一张LUT（不能使用相同逻辑设备名，多用户难实现）</li>
<li>每个用户设置一张LUT</li>
</ul>
<h3 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h3>
<p>每个设备驱动程序处理一种设备类型。</p>
<p><strong>任务：接收来自于设备无关的上层软件的抽象请求，并执行这个请求</strong></p>
<ul>
<li>自动配置和初始化子程序</li>
<li>I/O操作子程序：调用该子程序是系统调用的结果。执行该部分程序时，系统仍认为是和调用进程属同一个进程，只是由用户态变成核心态</li>
<li>中断服务子程序</li>
</ul>
<h2 id="io缓冲管理"><a class="markdownIt-Anchor" href="#io缓冲管理"></a> I/O缓冲管理</h2>
<p><mark>利用内存</mark></p>
<p>提高外设利用率</p>
<blockquote>
<ul>
<li>匹配CPU与外设的不同处理速度</li>
<li>减少对CPU的中断次数</li>
<li>提高CPU和I/O设备之间的并行性</li>
</ul>
</blockquote>
<h3 id="单缓冲"><a class="markdownIt-Anchor" href="#单缓冲"></a> 单缓冲</h3>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031016140.png" alt="" /></p>
<p>平均处理一个块所需的时间：从一个状态到下一次回到这个状态</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406061507940.png" alt="" /></p>
<p>总结：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo>+</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">Max(C,T)+M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></p>
<h3 id="双缓冲"><a class="markdownIt-Anchor" href="#双缓冲"></a> 双缓冲</h3>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031017779.png" alt="" /></p>
<p>平均处理一个块所需的时间：从工作区空，其中一个缓冲区满，另一个缓冲区空到回到这个状态</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>T</mi><mo separator="true">,</mo><mi>C</mi><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Max(T,C+M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></p>
<h3 id="环形缓冲"><a class="markdownIt-Anchor" href="#环形缓冲"></a> 环形缓冲</h3>
<p>多个指针区分空缓冲区，已装满数据的缓冲区，正在使用的缓冲区</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031019576.png" alt="" /></p>
<h3 id="缓冲池"><a class="markdownIt-Anchor" href="#缓冲池"></a> 缓冲池</h3>
<p>上面消耗大量内存空间，利用率不高。而缓冲池设置了多个可供若干进程共享的缓冲区</p>
<blockquote>
<p>相同类型的缓冲区链成队列：空缓冲队列，输入队列，输出队列<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031028853.png" alt="" /></p>
</blockquote>
<ul>
<li>收容输入：调用<code>Getbuf(emq)</code>从空缓冲队列取出队首，数据输入其中，装满后调用<code>Putbuf(inq,hin)</code>，将其挂在输入队列上。</li>
<li>提取输入：调用<code>Getbuf(inq)</code>从输入队列队首取出，提取数据后，调用<code>Putbuf(emq,sin)</code>，将其挂到空缓冲队列emq上。</li>
<li>收容输出：调用<code>Getbuf(emq)</code>从空缓冲队列取出队首，装满输出数据后，调用<code>Putbuf(outq,hout)</code>将缓冲区挂在outq末尾。</li>
<li>提取输出：调用<code>Getbuf(outq)</code>从输出缓冲队列取出队首，提取数据后，调用<code>Putbuf(emq,sout)</code>将缓冲区挂在空缓冲队列末尾。</li>
</ul>
<p><strong><mark>取队头，挂队尾</mark></strong></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031029889.png" alt="" /></p>
<h2 id="io设备管理"><a class="markdownIt-Anchor" href="#io设备管理"></a> I/O设备管理</h2>
<p>解决外设共享问题，以提高外设资源的利用率</p>
<ul>
<li>进程间交替使用外设（键盘&amp;鼠标）</li>
<li>通过一个虚拟设备把设备与应用进程隔开，只由虚拟设备使用设备</li>
</ul>
<h3 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h3>
<ol>
<li>设备控制表DCT：每个设备一张，描述设备特性和状态
<ul>
<li>设备队列队首指针：请求为得到满足的进程（PCB）</li>
<li>设备状态：忙/闲</li>
<li>控制器表指针</li>
<li>重复执行次数：发生错误重传</li>
</ul>
</li>
<li>控制器控制表</li>
<li>通道控制表</li>
<li>系统设备表</li>
</ol>
<h3 id="spooling技术"><a class="markdownIt-Anchor" href="#spooling技术"></a> SPOOLing技术</h3>
<p><mark>假脱机技术：软件方式模拟实现脱离主机的控制进行I/O操作</mark></p>
<p>应用程序进行I/O操作时，实际是和SPOOLing程序交换数据，从SPOOLing程序的缓冲池读出数据或把数据读入缓冲池，而不是跟实际的外设进行I/O操作</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406031104258.png" alt="" /></p>
<ul>
<li>输入井和输出井：<strong>磁盘</strong>上开辟的存储空间。模拟脱机输入输出</li>
<li>输入缓冲区和输出缓冲区：缓和CPU与磁盘之间的速度不匹配，在内存开辟的缓冲区。暂存输入设备送来的数据和将要传送给输出设备的数据</li>
<li>输入进程和输出进程</li>
</ul>
<h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h4>
<ul>
<li>高速模拟I/O操作</li>
<li>实现对独享设备的共享：由spooling程序提供虚拟设备，对独享设备依次共享使用（独占设备——&gt;共享设备）</li>
</ul>
<h2 id="io性能问题"><a class="markdownIt-Anchor" href="#io性能问题"></a> I/O性能问题</h2>
<ul>
<li>使CPU利用率尽可能不被I/O降低</li>
<li>使CPU尽可能摆脱I/O</li>
</ul>
<h1 id="磁盘管理"><a class="markdownIt-Anchor" href="#磁盘管理"></a> 磁盘管理</h1>
<p><strong>结构</strong></p>
<ul>
<li>磁盘</li>
<li>磁道：盘偏上以盘片中心为圆心，不同半径的同心圆</li>
<li>扇区：磁盘划分圆心角度相同的扇区，存储固定大小（盘块）</li>
<li>柱面：不同盘片相同半径的磁道组成，<strong>离轴心最远的编号为0</strong></li>
</ul>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062211722.png" alt="" /></p>
<p>读一个扇区：柱面&amp;磁头&amp;扇区三个参数</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062211175.png" alt="" /></p>
<h2 id="磁盘的组织和调度"><a class="markdownIt-Anchor" href="#磁盘的组织和调度"></a> 磁盘的组织和调度</h2>
<h3 id="组织模式"><a class="markdownIt-Anchor" href="#组织模式"></a> 组织模式</h3>
<h4 id="chs模式"><a class="markdownIt-Anchor" href="#chs模式"></a> CHS模式</h4>
<p>磁头数NH，柱面数NC，扇区数NS</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">磁</mi><mi mathvariant="normal">盘</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">量</mi><mo>=</mo><mi mathvariant="normal">磁</mi><mi mathvariant="normal">头</mi><mi mathvariant="normal">数</mi><mo>×</mo><mi mathvariant="normal">柱</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">数</mi><mo>×</mo><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">数</mi><mo>×</mo><mn>512</mn><mi mathvariant="normal">字</mi><mi mathvariant="normal">节</mi></mrow><annotation encoding="application/x-tex">			磁盘容量=磁头数×柱面数×扇区数×512字节
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">容</span><span class="mord cjk_fallback">量</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">头</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">柱</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">节</span></span></span></span></span></p>
<h4 id="lba模式"><a class="markdownIt-Anchor" href="#lba模式"></a> LBA模式</h4>
<blockquote>
<p>将磁盘驱动器看做一个一维的逻辑块的数组，逻辑块是最小的传输单位。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#lba =（＃c * H +＃h）* S +＃s-1</span><br></pre></td></tr></table></figure>
<ul>
<li>#c、#h、#s分别是磁柱、磁头、扇区的编号</li>
<li>#lba是逻辑区块编号</li>
<li>H=heads per cylinder，每个磁柱的磁头数</li>
<li>S=sectors per track，每磁道的扇区数</li>
</ul>
<h3 id="空间管理"><a class="markdownIt-Anchor" href="#空间管理"></a> 空间管理</h3>
<p>位图：每一个物理块对应一位，分配出去为0，否则为1.</p>
<p>空闲表：记录起始块号，块数</p>
<p>成组链接法：把空白物理块分成组，再通过指针把组与组之间链接起来<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062211981.png" alt="" /></p>
<h3 id="磁盘访问时间"><a class="markdownIt-Anchor" href="#磁盘访问时间"></a> 磁盘访问时间</h3>
<p>寻道时间：把磁头从当前位置移动到指定刺刀上的时间。s（启动磁盘），n（移动磁道数）</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>+</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">T_s=m\times n+s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></span></p>
<p>旋转延迟时间：r（旋转速度RPM：一分钟转几圈）</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>r</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>×</mo><mi>r</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>×</mo><mi>R</mi><mi>P</mi><mi>M</mi><mo>×</mo><mn>60</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_r=\frac{1}{2\times r}=\frac{1}{2\times RPM \times 60}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">6</span><span class="mord">0</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>传输时间：把数据从磁盘读出&amp;向磁盘写入数据。b（读写的字节数），r（旋转速度），N（磁道上的字节数）</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub><mo>=</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mo>×</mo><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_t=\frac{b}{r\times N}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.14077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>总访问时间：寻道时间+旋转延迟时间+传输时间</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub><mo>=</mo><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac><mo>+</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_a=T_s+\frac{1}{2r}+\frac{b}{rN}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h3 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法"></a> 磁盘调度算法</h3>
<p>先来先服务FCFS</p>
<blockquote>
<p>按访问请求到达的先后顺序。</p>
<p>优：简单公平</p>
<p>缺：相邻请求可能反复移动，效率低</p>
</blockquote>
<p>最短寻道时间优先SSTF：解决效率低</p>
<blockquote>
<p>优先选择据当前磁头最近的访问请求</p>
<p>优：改善磁盘平均服务时间</p>
<p>缺：饥饿现象，某些访问长期等待</p>
</blockquote>
<p>扫描算法SCAN电梯调度：解决饥饿</p>
<blockquote>
<p>磁头按一个方向移动，移动过程中对遇到的访问请求进行服务，知道磁头步进到==最内（最外）==调转扫描方向。</p>
<p>优：克服SSTF缺点，考虑了距离&amp;方向</p>
<p>缺：摆动式，两侧访问频率低于中间</p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062212022.png" alt="" style="zoom:80%;" />
</blockquote>
<p>循环扫描算法C-SCAN：解决两端不公平</p>
<blockquote>
<p>按照要访问的柱面位置的次序选择访问者。到达最后一个柱面后，带动磁头快速返回到0号柱面，返回时不服务任何。</p>
<p>优：增加两侧访问频率</p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062212869.png" alt="" style="zoom:80%;" />
</blockquote>
<img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" style="zoom:80%;" />
<h2 id="提高磁盘io性能"><a class="markdownIt-Anchor" href="#提高磁盘io性能"></a> 提高磁盘I/O性能</h2>
<ul>
<li>
<p>选择性能好的磁盘</p>
</li>
<li>
<p>并行化</p>
</li>
<li>
<p>采用适当的调度算法</p>
</li>
<li>
<p>设置磁盘高速缓冲区 <mark>在内存中</mark></p>
<blockquote>
<p>形式：独立缓存，以虚拟内存为缓存</p>
<p>数据交付：直接交付（copy开销），指针交付（内存管理复杂）</p>
<p>置换算法LRU</p>
<p>周期性写回：将disk cache中被修改过的内容写回磁盘</p>
</blockquote>
</li>
<li>
<p>优化数据布局：1.连续摆放，磁头移动距离最小 2.优化索引节点的分布</p>
</li>
<li>
<p>提交读：顺序访问，提前读入下一块到缓冲区</p>
</li>
<li>
<p>延迟写</p>
</li>
<li>
<p>虚拟盘</p>
</li>
</ul>
<h2 id="廉价冗余磁盘阵列raid"><a class="markdownIt-Anchor" href="#廉价冗余磁盘阵列raid"></a> 廉价冗余磁盘阵列—RAID</h2>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406060955933.png" alt="" style="zoom:80%;" />
<p>把多个相对便宜的硬盘组合成硬盘组，提供比单个硬盘更高的存储性能和提供数据冗余（用户数据损坏，利用冗余信息可以使损失数据得以恢复）的技术</p>
<ul>
<li>价格低，功效小，传输速率高（并行传输）</li>
<li>可提供容错功能</li>
</ul>
<img src="../../Sophomore/%E6%88%AA%E5%9B%BE/.png" alt="" style="zoom:80%;" />
<h3 id="raid0"><a class="markdownIt-Anchor" href="#raid0"></a> RAID0</h3>
<p>条带化存储：有N个磁盘组成的是单个磁盘读写速度的N倍</p>
<p>数据传输率高，没有数据冗余。<strong>但是没有冗余校验功能</strong></p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406060930608.png" alt="" style="zoom:80%;" />
<h3 id="raid1"><a class="markdownIt-Anchor" href="#raid1"></a> RAID1</h3>
<p>镜像存储：  通过磁盘数据镜像实现数据冗余， 在成对的独立磁盘上产生互为备份的数据。原始数据繁忙，直接从镜像拷贝读取数据。</p>
<p>读性能好，写性能由最差的磁盘决定，可靠性好，代价较高</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406060930375.png" alt="" /></p>
<h3 id="raid2"><a class="markdownIt-Anchor" href="#raid2"></a> RAID2</h3>
<p>海明码校验+条带存储，码距为3</p>
<p>需要多个磁盘来存放海明校验码信息，冗余磁盘数量与数据磁盘数量的对数成正比</p>
<p>易出错，没有商业化</p>
<h3 id="raid3"><a class="markdownIt-Anchor" href="#raid3"></a> RAID3</h3>
<p>奇偶校验+条带存储，读写要访问组中所有盘，每组一个校验盘</p>
<p>缺：恢复时间长， 奇偶校验盘成为瓶颈</p>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406060954795.png" alt="" style="zoom:80%;" />
<h1 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h1>
<h2 id="文件系统基本概念"><a class="markdownIt-Anchor" href="#文件系统基本概念"></a> 文件系统基本概念</h2>
<p>文件：数据存储和访问的单位，对用户数据的逻辑抽象。<mark>连续逻辑地址空间，对磁盘的抽象</mark></p>
<ul>
<li>用户：屏蔽访问外村上的数据的复杂性</li>
<li>磁盘等资源：提高资源的利用率，优化性能</li>
</ul>
<p>管理需求：</p>
<blockquote>
<ul>
<li>用户（使用逻辑文件）：使用的用户接口。</li>
<li>操作系统（组织和管理物理文件）：实现功能（管理存储空间，布局，存储位置）</li>
</ul>
</blockquote>
<h3 id="三个层次"><a class="markdownIt-Anchor" href="#三个层次"></a> 三个层次</h3>
<p>1.文件系统的接口：命令行接口，程序接口</p>
<p>2.对象操作管理的软件集合</p>
<p>3.对象及属性：文件，目录，磁盘存储空间</p>
<blockquote>
<p>目录</p>
<p>文件说明索引组成的用于文件检索的特殊文件。</p>
<p>内容：文件访问和控制的信息（文件名，文件类型，地址信息，访问控制信息，使用信息）</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062214839.png" alt="" /></p>
<p><strong>多级目录</strong>：通过绝对路径&amp;相对路径&amp;当前目录（.）&amp;上一级目录（…）</p>
<p><strong>层次清楚，解决文件重名问题，查找速度快，目录级别太多</strong></p>
</blockquote>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406061633709.png" alt="" /></p>
<h2 id="文件系统实现方法"><a class="markdownIt-Anchor" href="#文件系统实现方法"></a> 文件系统实现方法</h2>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062215020.png" alt="" /></p>
<h3 id="文件控制块"><a class="markdownIt-Anchor" href="#文件控制块"></a> 文件控制块</h3>
<blockquote>
<ul>
<li>基本信息：文件名，物理位置，文件逻辑结构，文件物理结构</li>
<li>访问控制信息：文件所有者，访问权限</li>
<li>使用信息：创建时间，上一次修改时间</li>
</ul>
</blockquote>
<p>文件控制块vs文件描述符</p>
<ul>
<li>
<p>文件控制块：描述文件基本信息</p>
</li>
<li>
<p>文件描述符：唯一标识一个打开的文件，非负整数</p>
</li>
</ul>
<h3 id="文件逻辑结构和物理结构"><a class="markdownIt-Anchor" href="#文件逻辑结构和物理结构"></a> 文件逻辑结构和物理结构</h3>
<h4 id="文件逻辑结构"><a class="markdownIt-Anchor" href="#文件逻辑结构"></a> 文件逻辑结构</h4>
<p>以字节为单位的流式结构、记录式文件结构（存取文件信息的最小单位是：记录）、树形结构</p>
<p>用户层面看：文件如何组织</p>
<ul>
<li>提高紧缩效率</li>
<li>便于修改</li>
<li>降低文件存储代价</li>
</ul>
<h4 id="文件物理结构"><a class="markdownIt-Anchor" href="#文件物理结构"></a> 文件物理结构</h4>
<p>操作系统角度：在存储介质上的存放方式</p>
<h5 id="连续顺序结构"><a class="markdownIt-Anchor" href="#连续顺序结构"></a> 连续（顺序）结构</h5>
<p>优：结构简单，效率高</p>
<p>缺：文件长度一经固定不易改变，不利于动态增加和修改</p>
<p><mark>适合变化不大的文件</mark></p>
<h5 id="串联链接文件"><a class="markdownIt-Anchor" href="#串联链接文件"></a> 串联/链接文件</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062215950.png" alt="" /></p>
<p>每个物理块的最后一个字为链接字，链首指针放在文件目录。</p>
<p>优：空间利用率高，便于动态扩充修改，顺序存取效率高（类似页式）</p>
<p>缺：随机存取效率太低，如果访问最后内容，实际访问整个文件；指针出错，可靠性低；链接指针占用空间。</p>
<h5 id="索引结构"><a class="markdownIt-Anchor" href="#索引结构"></a> 索引结构</h5>
<p>将每个物理块号存放在索引中，FCB只记录索引表的地址。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062215044.png" alt="" /></p>
<p>索引文件：数据文件+索引表</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062216575.png" alt="" /></p>
<p>先通过文件名读出索引块的内容，再通过索引块中的索引表找出文件的各个物理块号。</p>
<p>优（保持链接结构优点又避免缺点）：能顺序&amp;随机存取，满足文件动态增长，充分利用外存。</p>
<p>缺：索引表本身开销（内外存空间，存取时间）</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062216365.png" alt="" /></p>
<h6 id="索引表的组织"><a class="markdownIt-Anchor" href="#索引表的组织"></a> 索引表的组织</h6>
<ul>
<li>
<p>链接模式：一个盘块一个索引表，多个索引表链接起来</p>
</li>
<li>
<p>多级索引：将一个大文件的所有索引表的地址存在放另一个索引表中</p>
<p>直接索引——从索引表中直接读出磁盘块号</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062216958.png" alt="" /></p>
</li>
<li>
<p>综合：两者结合</p>
</li>
</ul>
<h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3>
<p>实现方法：</p>
<blockquote>
<ul>
<li>直接法：目录项=文件名+文件控制块</li>
<li>间接法：目录项=文件名+文件控制块的地址（索引号，如unix的inode）</li>
</ul>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062216156.png" alt="" style="zoom:80%;" />
</blockquote>
<p>长文件名：</p>
<blockquote>
<ul>
<li>文件名固定使用255字符：浪费空间</li>
<li>目录项长度，文件的属性信息（不变），文件名（可变）：文件被删除，占用的空间不易回收</li>
<li>目录项本身长度固定，把文件名统一放在目录文件的末尾。</li>
</ul>
</blockquote>
<p>查询：</p>
<blockquote>
<ul>
<li>顺序查询：依次扫描符号文件目录中的表目，将表目的名字字段与查找的符号名NAME比较</li>
<li>Hash查询：利用易于实现的变换函数，把每个符号名唯一的变换成符号表中的表目索引</li>
</ul>
</blockquote>
<p>便于共享的目录组织：使存储空间内保存一份副本，而所有要共享该文件的用户可用<mark>相同的或不同</mark>的文件名来访问它。</p>
<blockquote>
<p>软连接：符号连接，重定向到某一个文件（相当于快捷方式？）inode不增加</p>
<p>硬连接：不能针对目录创建、不能针对不存在的文件创建。innode 连接数就会增加 1</p>
</blockquote>
<p>保护文件：</p>
<blockquote>
<p>建立副本：同一文件保存到多个存储介质上（短小&amp;重要）</p>
<p>定时转储：每隔一段时间转储到其他存储介质上</p>
<p>一致性检查：</p>
<ul>
<li>磁盘块的一致性：</li>
</ul>
</blockquote>
<p>文件的存取控制：</p>
<blockquote>
<p>文件保护机制：</p>
<p>存取权限验证步骤：存取控制矩阵、存取控制表、用户权限表、口令</p>
</blockquote>
<p>文件的并发访问：多个进程并发访问同一文件</p>
<blockquote>
<ul>
<li>访问文件前必须先打开文件：多个进程访问同一个文件都使用内存中同一个目录内容，保证文件系统的一致性</li>
<li>文件锁定：协调对文件指定区域的互斥访问</li>
<li>进程间通信</li>
</ul>
</blockquote>
<p>文件系统性能提高：</p>
<blockquote>
<ul>
<li>
<p>块高速缓存：类似于cache</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406062217713.png" alt="" /></p>
</li>
</ul>
</blockquote>
<h1 id="final"><a class="markdownIt-Anchor" href="#final"></a> Final</h1>
<h2 id="客观题"><a class="markdownIt-Anchor" href="#客观题"></a> 客观题</h2>
<h3 id="课上小测"><a class="markdownIt-Anchor" href="#课上小测"></a> 课上小测</h3>
<ol>
<li>
<p>分时系统与批处理系统的主要开销是系统切换</p>
</li>
<li>
<p>计算机系统中网络带宽增长速度最快</p>
</li>
<li>
<p>DOS系统增加了网络功能，属于网络操作系统</p>
</li>
<li>
<p>（x）内存紧缩中用的重定位技术与程序链接过程中的重定位是一样的：前者动态重定位，后者编译链接过程中的重定位，主要原因是编译时程序地址在内存中的地址不确定，当多个程序编译链接后计算出程序地址的操作。</p>
</li>
<li>
<p>页式管理缺点：共享数据不方便。共享数据和非共享数据在同一页中，解决：分段管理</p>
</li>
<li>
<blockquote>
<p>关于多级页表，下列说法不正确的是：（单选）<br />
A. 能够减少页表占用内存的大小</p>
<p>B. 级数越多，平均访问内存的时间越长</p>
<p>C. 有效的页表项中都会存储页框号</p>
<p>D. 使用二级页表的平均访存性能优于一级页表</p>
</blockquote>
<p>答：D</p>
<p>多级页表会采用动态调入机制，有一些页表在不需要的时候不调入内存，解决了页表占用大量内存的问题（A正确）。页表级数越多，就需要越多次访问这些不同级的页表，也就是多次访问内存，平均访存时间会增加（B正确，D错误）。有效的页表项中必然会存储页框号，MMU正是凭借页表项中的页框号才找到物理地址（C正确）。</p>
</li>
<li>
<blockquote>
<p>在Intel x86下从段式地址到线性地址的转换中需要查找的对象可能是：（多选）<br />
A. 全局描述符表GDT</p>
<p>B. 局部描述符表LDT</p>
<p>C. 页目录</p>
<p>D. 页表</p>
</blockquote>
<p>答：A、B</p>
<p>逻辑地址的高位取出Segment Selector（相当于段号），然后通过查描述符表来找到对应段的页目录起始地址（x86采用二级页表）。这里的描述符可能查全局描述符表GDT，整个系统独一个；也有可能查局部描述符表LDT，每个进程拥有一个。</p>
</li>
<li>
<blockquote>
<p>关于段式管理描述不正确的有：（多选）<br />
A. 两个段的长度可以不同</p>
<p>B. 每个段内地址都从0开始</p>
<p>C. 段页式管理实质上等价于采用两级页表的页式管理</p>
<p>D. 段内地址是二维的、不连续的</p>
</blockquote>
<p>答：C、D</p>
<p>每个段内地址都从0开始是正确的，而再加上段长不一致，这也是段式地址是二维地址的原因，B正确。段页式管理相当于在页式管理之上再查一次段表，段式+一级页式相当于二级页表，但段式之下也可以嵌套多级页表，例如x86的段式+二级页表模式，相当于三级页表，一方面我们不能说段页式就一定相当于二级页表，另一方面我们也不能说段页式就和多级页表“等价”，二者还是有本质上的区别的，C错误。段式地址整体是二维的不连续的，但段内地址是从0开始的连续地址，D错误。</p>
</li>
<li>
<p>Intel X86下的CR3寄存器中保存的是<strong>页目录基地址</strong>。</p>
</li>
<li>
<p>以下哪个地址不可能是自映射页目录的地址？<br />
A. 0x8020 0000<br />
B. 0x0000 0000<br />
C. 0xC040 0000<br />
D. 0x7fdf f000</p>
<p>通过给出的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>D</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">PD_{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>D</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>P</mi><msub><mi>T</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>+</mo><mi>P</mi><msub><mi>T</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>&gt;</mo><mo>&gt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">PD_{base}=PT_{base}+PT_{base}&gt;&gt;10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>,如果不与4MB对齐则错误</p>
</li>
<li>
<p>采用页目录自映射方式，有助于实现用户进程的统一内存布局</p>
</li>
<li>
<blockquote>
<p>引入线程的优势包括：（多选）<br />
A. 有利于提高运行实体的创建和撤销效率</p>
<p>B. 有利于提高CPU利用率</p>
<p>C. 有利于提高多个共享数据的计算和IO任务的切换速度</p>
<p>D. 有利于提高多个并发任务间的通信效率</p>
</blockquote>
<p>答：A、B、C、D</p>
<p>免去进程切换的开销，切换上下文，提升了运行实体创建和撤销的效率，A正确。提升了进程内部的并发程度，进一步提高了CPU利用率，B正确。线程之间直接共享变量，一个线程进行IO，其他线程还可计算，C正确。线程共享变量，提高多个并发任务间的通信效率，D正确。</p>
</li>
<li>
<blockquote>
<p>以下说法正确的是：<br />
A. PThreads API 是一个 Unix 下的线程实现<br />
B. PThread_yield 的作用是中止当前线程执行并退出<br />
C. PThreads API 可为编程人员提供多线程编程的可移植性<br />
D. PThreads API 仅支持创建用户级线程</p>
</blockquote>
<p>答案：成为了IEEE标准不只Unix，A错误。释放CPU给其他线程，B错误。PThread API提供了多线程良好的可移植性，只需要操作系统支持其库函数即可，C正确。支持创建用户级线程和内核级线程，D错误。</p>
</li>
<li>
<blockquote>
<p>以下说法正确的是：（单选）<br />
A. 引用全局变量的函数一定不是线程安全的</p>
<p>B. 引用static变量的函数可以是线程安全的</p>
<p>C. 线程安全的函数一定是可重入的</p>
<p>D. 可重入的函数一定是线程安全的</p>
</blockquote>
<p>答：B</p>
<p><mark>线程安全！=可重入</mark></p>
</li>
<li>
<p>（x）在进程处于临界资源时不能进行处理机调度——当然可以，别与死锁弄混</p>
</li>
<li>
<p><strong>只要涉及时间片都是抢占！！！！多级反馈，时间片轮转</strong></p>
</li>
<li>
<blockquote>
<p>以下关于单调速率调度算法说法正确的是：（单选）<br />
A. 当进程数较多的时候，会导致CPU利用率下降到70%左右</p>
<p>B. 当所有进程请求的CPU利用率之和大于70%时，不存在满足所有进程实时性约束的调度方案</p>
<p>C. 当所有进程请求的CPU利用率之和小于69%时，一定存在满足所有进程实时性约束的调度方案</p>
<p>D. CPU利用率越高的进程越被优先调度</p>
</blockquote>
<p>答：C</p>
</li>
<li>
<p>信号量可解决任何同步互斥问题</p>
</li>
<li>
<blockquote>
<p>假设磁盘平均损坏时间是100000小时，采用2块这样磁盘组成RAID 0阵列，其平均损坏时间是：（单选）<br />
A. 200000小时</p>
<p>B. 100000小时</p>
<p>C. 50000小时</p>
<p>D. 25000小时</p>
</blockquote>
<p>答：C</p>
<p>RAID是一种把多块独立的硬盘（物理硬盘）按照不同方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据冗余的技术。RAID 0是最低级别的RAID，该级别该级仅提供了并行交叉存取，它虽然有效提高了磁盘IO速度，但并无冗余校验功能。其2块磁盘的平均损坏时间将是单个磁盘的一半。</p>
</li>
<li>
<p>SPOOLing程序和外设进行数据交换使用的是实际I/O。</p>
</li>
<li>
<p>（x）文件控制块中包含了文件描述符</p>
</li>
<li>
<p>（x）文件系统中的源程序文件是有结构的记录式文件——没有结构要求</p>
</li>
<li>
<p>用户态下不能直接进行系统调用。</p>
</li>
<li>
<p>用户进程通过____系统调用___请求操作系统执行需要更高权限的操作（先中断，进入用户态后进行系统调用）</p>
</li>
<li>
<p>下列关于可重入代码说法正确的有：<br />
A. 即使只有一个用户进程，使用不可重入代码也可能是不安全的         <mark>还有内核进程呢！</mark><br />
B. 可重入代码中一般不能使用全局变量<br />
C. 在多道程序下，共享可重入代码可以减少程序对内存的占用<br />
D. 可重入代码中一般不能使用静态变量<br />
【答案】A、B、C、D</p>
</li>
</ol>
<blockquote>
<ol>
<li>若一个用户进程通过read系统调用读取一个磁盘文件中的数据，则下列关于此过程的叙述中，正确的是  A   。</li>
</ol>
<p>Ⅰ、若该文件的数据不在内存，则该进程进入阻塞状态</p>
<p>Ⅱ、请求read系统调用会使CPU从用户态切换到核心态</p>
<p>Ⅲ、 read系统调用的参数应包含文件的名称</p>
<p>A. 仅Ⅰ、Ⅱ    B. 仅Ⅰ、Ⅲ  C. 仅Ⅱ、Ⅲ   D. Ⅰ、Ⅱ和Ⅲ</p>
</blockquote>
<p>首先要用open系统调用打开该文件。open中的参数包括文件的路径名和文件名，而read只需使用open返回的文件描述符，并不使用文件名作为参数。</p>
<p>read要求用户提供三个输入参数：</p>
<ul>
<li>文件描述符fd</li>
<li>buf缓冲区首址</li>
<li>传送的字节数n</li>
</ul>
<p>read的功能是试图从fd所指示的文件中读入n个字节的数据，并将它们送至由指针buf所指示的缓冲区中</p>
<h3 id="算法相关"><a class="markdownIt-Anchor" href="#算法相关"></a> 算法相关</h3>
<h4 id="寻找空闲分区"><a class="markdownIt-Anchor" href="#寻找空闲分区"></a> 寻找空闲分区</h4>
<h6 id="分配算法基于顺序搜索-2"><a class="markdownIt-Anchor" href="#分配算法基于顺序搜索-2"></a> 分配算法（基于顺序搜索）</h6>
<ul>
<li>首次适应：按<mark>地址递增</mark>顺序排序，选择第一个满足要求的。空闲分区以地址递增的次序排列，按顺序查找空闲分区链&amp;表。
<ul>
<li>低地址不断划分，出现小碎片。</li>
<li>每次从低地址开始，增加查找可用分区的开销。</li>
</ul>
</li>
<li>下次适应：循环列表，从上次查找结束的地方开始。以地址递增的循环列表。
<ul>
<li>空间利用更加均衡，不会非小的集中在一端。缺乏大的空闲分区。</li>
</ul>
</li>
<li>最佳适应：选择大小最接近的。按容量递增次序排列。
<ul>
<li>小碎片。</li>
</ul>
</li>
<li>最坏适应：寻找最大的空闲区。按容量递减次序排列。
<ul>
<li>大作业申请得不到满足。</li>
</ul>
</li>
</ul>
<h6 id="分配算法基于索引-2"><a class="markdownIt-Anchor" href="#分配算法基于索引-2"></a> 分配算法（基于索引）</h6>
<p>适合小系统，否则空闲分区表/链很大，检索速度慢。</p>
<ul>
<li>快速适应：按容量大小分类，常用大小的空闲区设立单独的空闲区链表。系统为多个空闲链表设立一张管理索引表。
<ul>
<li>效率高，仅需要根据程序长度，找到能容纳最小空闲区链表，取下第一块。</li>
<li>不会分割分区，不产生内存碎片。取下某链表第一个即可。</li>
<li>回收算法复杂。</li>
</ul>
</li>
<li>伙伴系统：（linux）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n-1}&lt;x&lt;2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>，如果找不到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>就找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>再切割成两个相等的（伙伴）。
<ul>
<li>两个块合并成一个更大的块，首地址必须是块大小的整数倍</li>
<li>伙伴地址： 两个大小相同的相邻块合并成一个更大的块时，<strong>首地址必须是块（合成后的块2倍）大小的整数倍</strong>。</li>
</ul>
</li>
</ul>
<h4 id="页面置换-2"><a class="markdownIt-Anchor" href="#页面置换-2"></a> 页面置换</h4>
<ul>
<li>最优置换：选择最长时间不需要访问的页面。（用于比较性研究）</li>
<li>先进先出：选择在主存驻留时间最长的一页淘汰（queue）。
<ul>
<li>性能较差，Belady异常（分配的页框增多，缺页率反而提高）</li>
</ul>
</li>
<li>改进的FIFO算法（second chance）：如果被淘汰的数据之前被访问过，则给第二次机会，同时清除标志位，否则直接淘汰。</li>
<li>改进的FIFO算法（clock）：环形循环指针。
<ul>
<li>无缺页错误：将访问页置1，指针不动</li>
<li>产生：
<ul>
<li>当前为1：置0，向前移，直至找到0</li>
<li>当前为0：替换，将其置1，向前移一位</li>
</ul>
</li>
</ul>
</li>
<li>最近最少使用LRU：选择在最近一段时间内最久不用的页面。
<ul>
<li>命中时：所有块的计数值与命中块的计数值比较，
<ul>
<li>
<p>如果某块计数值小于命中块的计数值， 则该块的计数值加 1</p>
</li>
<li>
<p>如果该块的计数值大于命中块的计数值，则数值不变。</p>
</li>
<li>
<p>最后将命中块的计数器清为0。</p>
</li>
</ul>
</li>
<li>访问未命中：计数值最大的块被替换。被替换的清0，其余加1.</li>
</ul>
</li>
<li>工作集算法：工作集指进程运行正在使用的页面集合。给定一个进程，记录其工作集。当需要进行页面替换时，选择不在工作集中的页面进行替换。</li>
</ul>
<h3 id="混淆区分"><a class="markdownIt-Anchor" href="#混淆区分"></a> 混淆区分</h3>
<ul>
<li>交换分区：<strong>磁盘</strong>。将OS暂时不用的数据放在这里。</li>
<li>块高速缓存：<strong>内存</strong>。相当于虚拟存储的cache。</li>
<li>页缓冲：<strong>内存</strong>。发生缺页中断时，不必首先写出置换页，而是将被选中的置换页面暂时保留在内存的缓冲区，批量写出到外存。减少IO次数。</li>
<li>输入井和输出井：<strong>磁盘</strong>。模拟脱机输入输出</li>
</ul>
<h2 id="计算题"><a class="markdownIt-Anchor" href="#计算题"></a> 计算题</h2>
<h3 id="内存管理-2"><a class="markdownIt-Anchor" href="#内存管理-2"></a> 内存管理</h3>
<p><strong>注意是大尾端还是小尾端，多少位！！！</strong></p>
<h3 id="同步与互斥-2"><a class="markdownIt-Anchor" href="#同步与互斥-2"></a> 同步与互斥</h3>
<p>大题：</p>
<p>初始化信号量semaphore，其他变量（注意可不可以定义其他变量）</p>
<ul>
<li>分析同步互斥关系。</li>
<li>同步即先V后P，互斥全部加上PV。</li>
<li>互斥信号量初始值为1，同步要看资源的多少。</li>
<li>遇到数量，优先考虑初值为N 的信号量</li>
<li>读/写者优先中，“优先”也可以看作资源</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">	cobegin&#123;<span class="comment">//并发执行</span></span><br><span class="line">		P1:&#123;</span><br><span class="line">            <span class="keyword">while</span>（<span class="literal">true</span>）&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">		P2:&#123;&#125;</span><br><span class="line">	&#125;coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h4>
<blockquote>
<p>读者写者问题（写者优先）: 1）共享读; 2）互斥写、读写互斥; 3）写者优先于读者（一 旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//读写互斥</span></span><br><span class="line"><span class="built_in">int</span> count=<span class="number">0</span>;<span class="comment">//记录进入读的进程数</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥访问count变量</span></span><br><span class="line">semaphore r=<span class="number">1</span>;<span class="comment">//当有写进程时，禁止所有读进程</span></span><br><span class="line"><span class="built_in">int</span> writecount=<span class="number">1</span>;<span class="comment">//记录进入的写进程数</span></span><br><span class="line">semaphore mutex1=<span class="number">1</span>;<span class="comment">//互斥访问writecount变量</span></span><br><span class="line">semaphore mutex3=<span class="number">1</span>;<span class="comment">//用于只要有写进程读进程一直阻塞，但如果都在一个队列写进程不能跳过，所以读进程被阻塞在mutex3中</span></span><br><span class="line">main()&#123;</span><br><span class="line">    cobegin&#123;</span><br><span class="line">        Read:&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                P(mutex3);</span><br><span class="line">                P(r);</span><br><span class="line">                P(mutex);</span><br><span class="line">                <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                    P(rw);</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                V(mutex);</span><br><span class="line">                V(r);</span><br><span class="line">                V(mutex3);</span><br><span class="line">                read;</span><br><span class="line">                P(mutex);</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                    V(rw);</span><br><span class="line">                &#125;</span><br><span class="line">                V(mutex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Write:&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                P(mutex1);</span><br><span class="line">                <span class="keyword">if</span>(writecount==<span class="number">0</span>)&#123;</span><br><span class="line">                    P(r);</span><br><span class="line">                &#125;</span><br><span class="line">                writecount++;</span><br><span class="line">                V(mutex1);</span><br><span class="line">                P(rw);</span><br><span class="line">                write;</span><br><span class="line">                V(rw);</span><br><span class="line">            	P(mutex1);</span><br><span class="line">                writecount--;</span><br><span class="line">                <span class="keyword">if</span>(writecount==<span class="number">0</span>)&#123;</span><br><span class="line">                    P(r);</span><br><span class="line">                &#125;</span><br><span class="line">                V(mutex1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作业调度"><a class="markdownIt-Anchor" href="#作业调度"></a> 作业调度</h3>
<h4 id="评价指标"><a class="markdownIt-Anchor" href="#评价指标"></a> 评价指标</h4>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406051631318.png" alt="" /></p>
<p>响应比=1+S/T （S：等待时间；T：运行时间）</p>
<p>T(响应时间)=N(进程数目)*q(时间片) 数目越多，时间片越小</p>
<h4 id="算法内容"><a class="markdownIt-Anchor" href="#算法内容"></a> 算法内容</h4>
<ul>
<li>
<p>先来先服务FCFS（非抢占）</p>
</li>
<li>
<p>短作业优先SJF（非抢占）</p>
</li>
<li>
<p>最短剩余时间优先SRTN（抢占）</p>
</li>
<li>
<p>最高响应比优先HRRN（非抢占）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>P</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">作</mi><mi mathvariant="normal">业</mi><mi mathvariant="normal">已</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">待</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">业</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">服</mi><mi mathvariant="normal">务</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow><annotation encoding="application/x-tex">RP=1+作业已等待时间/作业的服务时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">待</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord">/</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span></p>
</li>
<li>
<p>时间片轮转RR：所有就绪队列按照FCFS，刚用完时间片的排在队尾，<mark>刚出现的进程排在队首立即参与第一次调度</mark></p>
</li>
<li>
<p>优先级算法（抢占&amp;非抢占）</p>
</li>
<li>
<p>多级队列算法MQ：多个就绪队列，可有不同优先级，时间片长度</p>
</li>
<li>
<p>多级反馈队列MFQ：多个就绪队列，队列1优先级最高，优先级越低时间片越长，进程先到队列1，然后进入队列2，队列中FCFS。只有队列1为空才会调度队列2.</p>
</li>
<li>
<p>静态表调度：事先固定调度方案</p>
</li>
<li>
<p>单调速率调度RMS（静态，抢占）：任务周期越小优先级越高先被调度，优先级一样随机选择。判断任务集可调度（C为运行时间，T为周期）：<strong>注意周期，周期内运行完的不用再考虑了！</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub></mfrac><mo>≤</mo><mi>n</mi><mo stretchy="false">(</mo><mroot><mn>2</mn><mi>n</mi></mroot><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>≈</mo><mn>0.69</mn></mrow><annotation encoding="application/x-tex">\sum^n_{i=1}\frac{C_i}{T_i}\leq n(\sqrt[n]{2}-1)\approx0.69
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.206095em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738594em;"><span style="top:-3.023314em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.956095em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.916095em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08390500000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">9</span></span></span></span></span></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406040017236.png" alt="" /></p>
</li>
<li>
<p>最早截止期优先EDF（抢占）：绝对截止时间越早优先。任务集可调度：<mark>计算出最小公倍数的周期情况</mark></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub></mfrac><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum^n_{i=1}\frac{C_i}{T_i}\leq1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406040020669.png" alt="" /></p>
</li>
</ul>
<h3 id="死锁-2"><a class="markdownIt-Anchor" href="#死锁-2"></a> 死锁</h3>
<h4 id="资源分配图-2"><a class="markdownIt-Anchor" href="#资源分配图-2"></a> 资源分配图</h4>
<h5 id="画"><a class="markdownIt-Anchor" href="#画"></a> 画</h5>
<ul>
<li>资源为方块，有几个资源里面就有几个圆。</li>
<li>进程为圆</li>
<li>申请资源（need）：进程-&gt;资源</li>
<li>已经分配（allocate）：资源-&gt;进程</li>
</ul>
<h5 id="化简"><a class="markdownIt-Anchor" href="#化简"></a> 化简</h5>
<ul>
<li>计算出所有资源的空闲量：总数-出度</li>
<li>看每个进程：如果请求边（进程的出边）&lt;=资源空闲量，删去所有边</li>
<li>重复1,2过程</li>
</ul>
<h4 id="银行家算法-2"><a class="markdownIt-Anchor" href="#银行家算法-2"></a> 银行家算法</h4>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406032227975.png" alt=""  />
<table>
<thead>
<tr>
<th>进程号</th>
<th>work</th>
<th>allocation</th>
<th>need</th>
<th>work+alloc</th>
<th>finish</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>3 3 2</td>
<td>2 0 0</td>
<td>1 2 2</td>
<td>5 3 2</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>如果<code>work&gt;=need</code>，即可完成该进程</p>
<h3 id="文件系统-2"><a class="markdownIt-Anchor" href="#文件系统-2"></a> 文件系统</h3>
<p><mark>文件名按顺序，读取目录项不一定顺序！！！</mark></p>
<h4 id="文件物理结构-2"><a class="markdownIt-Anchor" href="#文件物理结构-2"></a> 文件物理结构</h4>
<h5 id="连续结构"><a class="markdownIt-Anchor" href="#连续结构"></a> 连续结构</h5>
<img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406040026019.png" alt="" style="zoom:67%;" />
<h5 id="串联链接结构"><a class="markdownIt-Anchor" href="#串联链接结构"></a> 串联/链接结构</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406040032518.png" alt="" /></p>
<h5 id="索引结构-2"><a class="markdownIt-Anchor" href="#索引结构-2"></a> 索引结构</h5>
<p>inode：索引节点，存储文件或目录的属性信息和数据所在的物理块信息。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406040958299.png" alt="" /></p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406040036717.png" alt="" /></p>
<h4 id="计算文件大小"><a class="markdownIt-Anchor" href="#计算文件大小"></a> 计算文件大小</h4>
<p>直接索引：文件inode-&gt;索引表-&gt;数据块</p>
<p>一级及以上的索引表大小等同于数据块大小</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">块</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">小</mi><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">数</mi><mo>+</mo><mi mathvariant="normal">一</mi><mi mathvariant="normal">级</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">数</mi><mo>×</mo><mfrac><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">块</mi></mrow><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">块</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">数</mi></mrow></mfrac><mo>+</mo><mi mathvariant="normal">二</mi><mi mathvariant="normal">级</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">数</mi><mo>×</mo><msup><mfrac><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">块</mi></mrow><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">块</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">数</mi></mrow></mfrac><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">数据块大小\times (直接索引数+一级索引数\times\frac{数据块}{数据块地址字节数}+二级索引数\times\frac{数据块}{数据块地址字节数}^2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">小</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">级</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.363em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">块</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">级</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.567008em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">块</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.881008em;"><span style="top:-3.1299em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<h4 id="读取文件"><a class="markdownIt-Anchor" href="#读取文件"></a> 读取文件</h4>
<h5 id="直接读取不说就是直接读取"><a class="markdownIt-Anchor" href="#直接读取不说就是直接读取"></a> 直接读取（不说就是直接读取）</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406041057210.png" alt="" /></p>
<blockquote>
<p>文件平均大小为100KB，磁盘物理块的大小为1KB，根目录的目录项已读入内存中，目标文件f在第三级目录下，且其对应的第三级目录的目录项可以一次从磁盘读出，访问文件f中的一个块平均需要访问几次磁盘？</p>
</blockquote>
<ul>
<li>直接从根目录目录项获得usr2的物理块号，一个磁盘块可以包含8个目录项，所以读取全部第三级目录项需要16次磁盘读取；平均需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>16</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>8.5</mn></mrow><annotation encoding="application/x-tex">(1+16)/2=8.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li>
<li>第三级目录的目录项可以一次读出，需要一次</li>
<li>访问文件f最少需要1次，最多需要100次，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>100</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>50.5</mn></mrow><annotation encoding="application/x-tex">(1+100)/2=50.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li>
<li>一共需要8.5+1+50.5=60</li>
</ul>
<blockquote>
<p>如果采用i节点的方法来构建文件目录，假定文件名占14个字节，i节点的指针占2个字节。如果仅采用直接索引，每个第三级目录下的文件数不超过50个，且根目录的i节点已读入内存，访问第三级目录下的一个文件的一个块平均需要访问几次磁盘？</p>
</blockquote>
<ul>
<li>通过根目录的inode读取根目录内容，1次；从而获得usr2的inode物理块号，读取usr2的inode，1次</li>
<li>读取usr目录内容，最多需要2次。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">(1+2)/2=1.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li>
<li>获得了dx的inode的物理块号，读取需要1次，再读取dx的目录项需要1次；读取文件1次</li>
<li>一共需要1+1+1.5+1+1+1=6.5</li>
</ul>
<blockquote>
<p>假设该文件系统的空间最大容量为16ZB(1ZB=270B)。如果文件的 FCB 中包括512字节的索引区，且允许采用一级索引进行组织，那么该文件系统支持的最大文件是多少字节？</p>
</blockquote>
<p>数据块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>，需要64/8个字节。索引区存放64个磁盘号。一级索引。每个索引都指向一个索引表（1KB/8个一级索引）</p>
<p>文件最大为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn><mo>×</mo><mfrac><mrow><mn>1</mn><mi>K</mi><mi>B</mi></mrow><mn>8</mn></mfrac><mo>×</mo><mn>1</mn><mi>K</mi><mi>B</mi><mo>=</mo><mn>8</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">64\times \frac{1KB}{8}\times 1KB=8MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></p>
<h5 id="inode方式读取"><a class="markdownIt-Anchor" href="#inode方式读取"></a> inode方式读取</h5>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406041044413.png" alt="" /></p>
<ul>
<li>通过根目录inode获得根目录目录块块号，读取根目录内容，获得tmp目录的inode所在的物理块号</li>
<li>读取tmp的inode，获得tmp目录项所在的物理块号</li>
<li>读取tmp目录内容，获得hello的inode的物理块号</li>
<li>读取hello的inode，获得hello的物理块号</li>
<li>读取hello数据</li>
</ul>
<p>至少读取5次。</p>
<p><img src="https://gitee.com/bxrbxr/images/raw/master/imgs/202406041044898.png" alt="" /></p>
<h4 id="磁盘"><a class="markdownIt-Anchor" href="#磁盘"></a> 磁盘</h4>
<p><mark>单位统一</mark></p>
<p>寻道时间：把磁头从当前位置移动到指定刺刀上的时间。s（启动磁盘），n（移动磁道数）</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>+</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">T_s=m\times n+s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></span></p>
<p>旋转延迟时间：r（旋转速度RPM）</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>r</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>×</mo><mi>r</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>×</mo><mi>R</mi><mi>P</mi><mi>M</mi><mo>×</mo><mn>60</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_r=\frac{1}{2\times r}=\frac{1}{2\times RPM \times 60}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">6</span><span class="mord">0</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>传输时间：把数据从磁盘读出&amp;向磁盘写入数据。b（读写的字节数），r（旋转速度），N（磁道上的字节数）</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub><mo>=</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mo>×</mo><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_t=\frac{b}{r\times N}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.14077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>总访问时间：寻道时间+旋转延迟时间+传输时间</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub><mo>=</mo><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac><mo>+</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_a=T_s+\frac{1}{2r}+\frac{b}{rN}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><strong>注意一共要读取多少个块，乘几 传输时间的写字节数不一定等于读的。比如完整读三个数据块12KB，实际文件大小为10KB</strong></p>
<p><mark>所以传输时间分开加！不要跟着乘在里面！！！</mark></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">bubble</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/24/OS/">http://example.com/2024/07/24/OS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">bubble's blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/12/18/compiler/"><i class="fa fa-chevron-left">  </i><span>编译</span></a></div><div class="next-post pull-right"><a href="/2024/07/24/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span>数据库</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/img/background.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2024 By bubble</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>